{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Prop = Prop;\nconst errors_1 = require(\"../errors\");\nconst mongoose_constants_1 = require(\"../mongoose.constants\");\nconst type_metadata_storage_1 = require(\"../storages/type-metadata.storage\");\nconst TYPE_METADATA_KEY = 'design:type';\nfunction Prop(options) {\n  return (target, propertyKey) => {\n    options = options || {};\n    const isRawDefinition = options[mongoose_constants_1.RAW_OBJECT_DEFINITION];\n    if (!options.type && !Array.isArray(options) && !isRawDefinition) {\n      const type = Reflect.getMetadata(TYPE_METADATA_KEY, target, propertyKey);\n      if (type === Array) {\n        options.type = [];\n      } else if (type && type !== Object) {\n        options.type = type;\n      } else {\n        throw new errors_1.CannotDetermineTypeError(target.constructor?.name, propertyKey);\n      }\n    }\n    type_metadata_storage_1.TypeMetadataStorage.addPropertyMetadata({\n      target: target.constructor,\n      propertyKey: propertyKey,\n      options: options\n    });\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Prop","errors_1","require","mongoose_constants_1","type_metadata_storage_1","TYPE_METADATA_KEY","options","target","propertyKey","isRawDefinition","RAW_OBJECT_DEFINITION","type","Array","isArray","Reflect","getMetadata","CannotDetermineTypeError","constructor","name","TypeMetadataStorage","addPropertyMetadata"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/mongoose/dist/decorators/prop.decorator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Prop = Prop;\nconst errors_1 = require(\"../errors\");\nconst mongoose_constants_1 = require(\"../mongoose.constants\");\nconst type_metadata_storage_1 = require(\"../storages/type-metadata.storage\");\nconst TYPE_METADATA_KEY = 'design:type';\nfunction Prop(options) {\n    return (target, propertyKey) => {\n        options = (options || {});\n        const isRawDefinition = options[mongoose_constants_1.RAW_OBJECT_DEFINITION];\n        if (!options.type && !Array.isArray(options) && !isRawDefinition) {\n            const type = Reflect.getMetadata(TYPE_METADATA_KEY, target, propertyKey);\n            if (type === Array) {\n                options.type = [];\n            }\n            else if (type && type !== Object) {\n                options.type = type;\n            }\n            else {\n                throw new errors_1.CannotDetermineTypeError(target.constructor?.name, propertyKey);\n            }\n        }\n        type_metadata_storage_1.TypeMetadataStorage.addPropertyMetadata({\n            target: target.constructor,\n            propertyKey: propertyKey,\n            options: options,\n        });\n    };\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,IAAI,GAAGA,IAAI;AACnB,MAAMC,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAC7D,MAAME,uBAAuB,GAAGF,OAAO,CAAC,mCAAmC,CAAC;AAC5E,MAAMG,iBAAiB,GAAG,aAAa;AACvC,SAASL,IAAIA,CAACM,OAAO,EAAE;EACnB,OAAO,CAACC,MAAM,EAAEC,WAAW,KAAK;IAC5BF,OAAO,GAAIA,OAAO,IAAI,CAAC,CAAE;IACzB,MAAMG,eAAe,GAAGH,OAAO,CAACH,oBAAoB,CAACO,qBAAqB,CAAC;IAC3E,IAAI,CAACJ,OAAO,CAACK,IAAI,IAAI,CAACC,KAAK,CAACC,OAAO,CAACP,OAAO,CAAC,IAAI,CAACG,eAAe,EAAE;MAC9D,MAAME,IAAI,GAAGG,OAAO,CAACC,WAAW,CAACV,iBAAiB,EAAEE,MAAM,EAAEC,WAAW,CAAC;MACxE,IAAIG,IAAI,KAAKC,KAAK,EAAE;QAChBN,OAAO,CAACK,IAAI,GAAG,EAAE;MACrB,CAAC,MACI,IAAIA,IAAI,IAAIA,IAAI,KAAKf,MAAM,EAAE;QAC9BU,OAAO,CAACK,IAAI,GAAGA,IAAI;MACvB,CAAC,MACI;QACD,MAAM,IAAIV,QAAQ,CAACe,wBAAwB,CAACT,MAAM,CAACU,WAAW,EAAEC,IAAI,EAAEV,WAAW,CAAC;MACtF;IACJ;IACAJ,uBAAuB,CAACe,mBAAmB,CAACC,mBAAmB,CAAC;MAC5Db,MAAM,EAAEA,MAAM,CAACU,WAAW;MAC1BT,WAAW,EAAEA,WAAW;MACxBF,OAAO,EAAEA;IACb,CAAC,CAAC;EACN,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
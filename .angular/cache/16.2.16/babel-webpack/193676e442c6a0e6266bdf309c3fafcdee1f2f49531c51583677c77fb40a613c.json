{"ast":null,"code":"import { defaultMetadataStorage } from './storage';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\nfunction instantiateArrayType(arrayType) {\n  const array = new arrayType();\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n  return array;\n}\nexport class TransformOperationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(transformationType, options) {\n    this.transformationType = transformationType;\n    this.options = options;\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n    this.recursionStack = new Set();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  transform(source, value, targetType, arrayType, isMap, level = 0) {\n    if (Array.isArray(value) || value instanceof Set) {\n      const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n      value.forEach((subValue, index) => {\n        const subSource = source ? source[index] : undefined;\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          let realTargetType;\n          if (typeof targetType !== 'function' && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(subType => subType.name === subValue[targetType.options.discriminator.property]);\n              const options = {\n                newObject: newValue,\n                object: subValue,\n                property: undefined\n              };\n              const newType = targetType.typeFunction(options);\n              realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n              if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(subType => subType.value === subValue.constructor).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n          const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n          if (newValue instanceof Set) {\n            newValue.add(value);\n          } else {\n            newValue.push(value);\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue instanceof Set) {\n            newValue.add(subValue);\n          } else {\n            newValue.push(subValue);\n          }\n        }\n      });\n      return newValue;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise((resolve, reject) => {\n        value.then(data => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)), reject);\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) if (!Array.isArray(value) && value.constructor === Array) {\n        // Somebody attempts to convert special Array like object to Array, eg:\n        // const evilObject = { '100000000': '100000000', __proto__: [] };\n        // This could be used to cause Denial-of-service attack so we don't allow it.\n        // See prevent-array-bomb.spec.ts for more details.\n      } else {\n        // We are good we can use the built-in constructor\n        targetType = value.constructor;\n      }\n      if (!targetType && source) targetType = source.constructor;\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n      const keys = this.getKeys(targetType, value, isMap);\n      let newValue = source ? source : {};\n      if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new targetType();\n        } else {\n          newValue = {};\n        }\n      }\n      // traverse over keys\n      for (const key of keys) {\n        if (key === '__proto__' || key === 'constructor') {\n          continue;\n        }\n        const valueKey = key;\n        let newValueKey = key,\n          propertyName = key;\n        if (!this.options.ignoreDecorators && targetType) {\n          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        }\n        // get a subvalue\n        let subValue = undefined;\n        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n          /**\n           * This section is added for the following report:\n           * https://github.com/typestack/class-transformer/issues/596\n           *\n           * We should not call functions or constructors when transforming to class.\n           */\n          subValue = value[valueKey];\n        } else {\n          if (value instanceof Map) {\n            subValue = value.get(valueKey);\n          } else if (value[valueKey] instanceof Function) {\n            subValue = value[valueKey]();\n          } else {\n            subValue = value[valueKey];\n          }\n        }\n        // determine a type\n        let type = undefined,\n          isSubValueMap = subValue instanceof Map;\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          const metadata = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n          if (metadata) {\n            const options = {\n              newObject: newValue,\n              object: value,\n              property: propertyName\n            };\n            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n            if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata.options.discriminator.subTypes.find(subType => {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? type = newType : type = type.value;\n                  if (!metadata.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      delete subValue[metadata.options.discriminator.property];\n                    }\n                  }\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  if (subValue) {\n                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(subType => subType.value === subValue.constructor).name;\n                  }\n                }\n              } else {\n                type = metadata;\n              }\n            } else {\n              type = newType;\n            }\n            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n          } else if (this.options.targetMaps) {\n            // try to find a type in target maps\n            this.options.targetMaps.filter(map => map.target === targetType && !!map.properties[propertyName]).forEach(map => type = map.properties[propertyName]);\n          } else if (this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            const reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        }\n        // if value is an array try to get its custom array type\n        const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType(targetType, propertyName) : undefined;\n        // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n        const subSource = source ? source[valueKey] : undefined;\n        // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n        // if newValue is a source object that has method that match newKeyName then skip it\n        if (newValue.constructor.prototype) {\n          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS) && (\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))\n            //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            continue;\n        }\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          let finalValue;\n          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey];\n            // Apply custom transformation\n            finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);\n            // If nothing change, it means no custom transformation was applied, so use the subValue.\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n            // Apply the default transformation\n            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n              finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);\n            }\n          }\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          let finalValue = subValue;\n          finalValue = this.applyCustomTransformations(finalValue, targetType, key, value, this.transformationType);\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      }\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n      return newValue;\n    } else {\n      return value;\n    }\n  }\n  applyCustomTransformations(value, target, key, obj, transformationType) {\n    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n    // apply versioning options\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n        return this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    }\n    // apply grouping options\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n        return this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(metadata => {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n    metadatas.forEach(metadata => {\n      value = metadata.transformFn({\n        value,\n        key,\n        obj,\n        type: transformationType,\n        options: this.options\n      });\n    });\n    return value;\n  }\n  // preventing circular references\n  isCircular(object) {\n    return this.recursionStack.has(object);\n  }\n  getReflectedType(target, propertyName) {\n    if (!target) return undefined;\n    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  }\n  getKeys(target, object, isMap) {\n    // determine exclusion strategy\n    let strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n    // get all keys that need to expose\n    let keys = [];\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n    /**\n     * If decorators are ignored but we don't want the extraneous values, then we use the\n     * metadata to decide which property is needed, but doesn't apply the decorator effect.\n     */\n    if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n      const exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      keys = [...exposedProperties, ...excludedProperties];\n    }\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n          return key;\n        });\n      }\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      }\n      // exclude excluded properties\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      if (excludedProperties.length > 0) {\n        keys = keys.filter(key => {\n          return !excludedProperties.includes(key);\n        });\n      }\n      // apply versioning options\n      if (this.options.version !== undefined) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      }\n      // apply grouping options\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n        });\n      }\n    }\n    // exclude prefixed properties\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {\n        return key.substr(0, prefix.length) !== prefix;\n      }));\n    }\n    // make sure we have unique keys\n    keys = keys.filter((key, index, self) => {\n      return self.indexOf(key) === index;\n    });\n    return keys;\n  }\n  checkVersion(since, until) {\n    let decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n    return decision;\n  }\n  checkGroups(groups) {\n    if (!groups) return true;\n    return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n  }\n}","map":{"version":3,"names":["defaultMetadataStorage","TransformationType","getGlobal","isPromise","instantiateArrayType","arrayType","array","Set","TransformOperationExecutor","constructor","transformationType","options","recursionStack","transform","source","value","targetType","isMap","level","Array","isArray","newValue","PLAIN_TO_CLASS","forEach","subValue","index","subSource","undefined","enableCircularCheck","isCircular","realTargetType","discriminator","property","subTypes","find","subType","name","newObject","object","newType","typeFunction","keepDiscriminatorProperty","CLASS_TO_CLASS","CLASS_TO_PLAIN","Map","add","push","String","Number","Boolean","Date","valueOf","Buffer","from","Promise","resolve","reject","then","data","Object","keys","getKeys","key","valueKey","newValueKey","propertyName","ignoreDecorators","exposeMetadata","findExposeMetadataByCustomName","findExposeMetadata","get","Function","type","isSubValueMap","metadata","findTypeMetadata","reflectedType","targetMaps","filter","map","target","properties","enableImplicitConversion","Reflect","getMetadata","prototype","getReflectedType","descriptor","getOwnPropertyDescriptor","set","transformKey","finalValue","applyCustomTransformations","exposeDefaultValues","exposeUnsetFields","delete","obj","metadatas","findTransformMetadatas","version","checkVersion","since","until","groups","length","checkGroups","transformFn","has","meta","strategy","getStrategy","excludeExtraneousValues","exposedProperties","getExposedProperties","excludedProperties","getExcludedProperties","concat","includes","excludePrefixes","every","prefix","substr","self","indexOf","decision","some","optionGroup"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/class-transformer/esm2015/TransformOperationExecutor.js"],"sourcesContent":["import { defaultMetadataStorage } from './storage';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\nfunction instantiateArrayType(arrayType) {\n    const array = new arrayType();\n    if (!(array instanceof Set) && !('push' in array)) {\n        return [];\n    }\n    return array;\n}\nexport class TransformOperationExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(transformationType, options) {\n        this.transformationType = transformationType;\n        this.options = options;\n        // -------------------------------------------------------------------------\n        // Private Properties\n        // -------------------------------------------------------------------------\n        this.recursionStack = new Set();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    transform(source, value, targetType, arrayType, isMap, level = 0) {\n        if (Array.isArray(value) || value instanceof Set) {\n            const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n                ? instantiateArrayType(arrayType)\n                : [];\n            value.forEach((subValue, index) => {\n                const subSource = source ? source[index] : undefined;\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let realTargetType;\n                    if (typeof targetType !== 'function' &&\n                        targetType &&\n                        targetType.options &&\n                        targetType.options.discriminator &&\n                        targetType.options.discriminator.property &&\n                        targetType.options.discriminator.subTypes) {\n                        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find(subType => subType.name === subValue[targetType.options.discriminator.property]);\n                            const options = { newObject: newValue, object: subValue, property: undefined };\n                            const newType = targetType.typeFunction(options);\n                            realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n                            if (!targetType.options.keepDiscriminatorProperty)\n                                delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(subType => subType.value === subValue.constructor).name;\n                        }\n                    }\n                    else {\n                        realTargetType = targetType;\n                    }\n                    const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n                    if (newValue instanceof Set) {\n                        newValue.add(value);\n                    }\n                    else {\n                        newValue.push(value);\n                    }\n                }\n                else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue instanceof Set) {\n                        newValue.add(subValue);\n                    }\n                    else {\n                        newValue.push(subValue);\n                    }\n                }\n            });\n            return newValue;\n        }\n        else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n        }\n        else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n        }\n        else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n        }\n        else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n        }\n        else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n        }\n        else if (isPromise(value) && !isMap) {\n            return new Promise((resolve, reject) => {\n                value.then((data) => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)), reject);\n            });\n        }\n        else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n            // Note: We should not enter this, as promise has been handled above\n            // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n            return value; // skip promise transformation\n        }\n        else if (typeof value === 'object' && value !== null) {\n            // try to guess the type\n            if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n                if (!Array.isArray(value) && value.constructor === Array) {\n                    // Somebody attempts to convert special Array like object to Array, eg:\n                    // const evilObject = { '100000000': '100000000', __proto__: [] };\n                    // This could be used to cause Denial-of-service attack so we don't allow it.\n                    // See prevent-array-bomb.spec.ts for more details.\n                }\n                else {\n                    // We are good we can use the built-in constructor\n                    targetType = value.constructor;\n                }\n            if (!targetType && source)\n                targetType = source.constructor;\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n            const keys = this.getKeys(targetType, value, isMap);\n            let newValue = source ? source : {};\n            if (!source &&\n                (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                    this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                }\n                else if (targetType) {\n                    newValue = new targetType();\n                }\n                else {\n                    newValue = {};\n                }\n            }\n            // traverse over keys\n            for (const key of keys) {\n                if (key === '__proto__' || key === 'constructor') {\n                    continue;\n                }\n                const valueKey = key;\n                let newValueKey = key, propertyName = key;\n                if (!this.options.ignoreDecorators && targetType) {\n                    if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n                    }\n                    else if (this.transformationType === TransformationType.CLASS_TO_PLAIN ||\n                        this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n                // get a subvalue\n                let subValue = undefined;\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                    /**\n                     * This section is added for the following report:\n                     * https://github.com/typestack/class-transformer/issues/596\n                     *\n                     * We should not call functions or constructors when transforming to class.\n                     */\n                    subValue = value[valueKey];\n                }\n                else {\n                    if (value instanceof Map) {\n                        subValue = value.get(valueKey);\n                    }\n                    else if (value[valueKey] instanceof Function) {\n                        subValue = value[valueKey]();\n                    }\n                    else {\n                        subValue = value[valueKey];\n                    }\n                }\n                // determine a type\n                let type = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n                }\n                else if (targetType) {\n                    const metadata = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n                    if (metadata) {\n                        const options = { newObject: newValue, object: value, property: propertyName };\n                        const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n                        if (metadata.options &&\n                            metadata.options.discriminator &&\n                            metadata.options.discriminator.property &&\n                            metadata.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata.options.discriminator.subTypes.find(subType => {\n                                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                                            return subType.name === subValue[metadata.options.discriminator.property];\n                                        }\n                                    });\n                                    type === undefined ? (type = newType) : (type = type.value);\n                                    if (!metadata.options.keepDiscriminatorProperty) {\n                                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                                            delete subValue[metadata.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    if (subValue) {\n                                        subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(subType => subType.value === subValue.constructor).name;\n                                    }\n                                }\n                            }\n                            else {\n                                type = metadata;\n                            }\n                        }\n                        else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n                    }\n                    else if (this.options.targetMaps) {\n                        // try to find a type in target maps\n                        this.options.targetMaps\n                            .filter(map => map.target === targetType && !!map.properties[propertyName])\n                            .forEach(map => (type = map.properties[propertyName]));\n                    }\n                    else if (this.options.enableImplicitConversion &&\n                        this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        const reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n                // if value is an array try to get its custom array type\n                const arrayType = Array.isArray(value[valueKey])\n                    ? this.getReflectedType(targetType, propertyName)\n                    : undefined;\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                const subSource = source ? source[valueKey] : undefined;\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                        this.transformationType === TransformationType.CLASS_TO_CLASS) &&\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\n                        ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function))\n                        //  || TransformationType === TransformationType.CLASS_TO_CLASS\n                        continue;\n                }\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n                    let finalValue;\n                    if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n                    }\n                    else {\n                        if (subValue === undefined && this.options.exposeDefaultValues) {\n                            // Set default value if nothing provided\n                            finalValue = newValue[newValueKey];\n                        }\n                        else {\n                            finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n                            finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);\n                        }\n                    }\n                    if (finalValue !== undefined || this.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n                else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    let finalValue = subValue;\n                    finalValue = this.applyCustomTransformations(finalValue, targetType, key, value, this.transformationType);\n                    if (finalValue !== undefined || this.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n            }\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n            return newValue;\n        }\n        else {\n            return value;\n        }\n    }\n    applyCustomTransformations(value, target, key, obj, transformationType) {\n        let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                return this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                return this.checkGroups(metadata.options.groups);\n            });\n        }\n        else {\n            metadatas = metadatas.filter(metadata => {\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n            });\n        }\n        metadatas.forEach(metadata => {\n            value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });\n        });\n        return value;\n    }\n    // preventing circular references\n    isCircular(object) {\n        return this.recursionStack.has(object);\n    }\n    getReflectedType(target, propertyName) {\n        if (!target)\n            return undefined;\n        const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    }\n    getKeys(target, object, isMap) {\n        // determine exclusion strategy\n        let strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === 'none')\n            strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n        // get all keys that need to expose\n        let keys = [];\n        if (strategy === 'exposeAll' || isMap) {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            }\n            else {\n                keys = Object.keys(object);\n            }\n        }\n        if (isMap) {\n            // expose & exclude do not apply for map keys only to fields\n            return keys;\n        }\n        /**\n         * If decorators are ignored but we don't want the extraneous values, then we use the\n         * metadata to decide which property is needed, but doesn't apply the decorator effect.\n         */\n        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n            const exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            keys = [...exposedProperties, ...excludedProperties];\n        }\n        if (!this.options.ignoreDecorators && target) {\n            // add all exposed to list of keys\n            let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            }\n            else {\n                keys = keys.concat(exposedProperties);\n            }\n            // exclude excluded properties\n            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties.length > 0) {\n                keys = keys.filter(key => {\n                    return !excludedProperties.includes(key);\n                });\n            }\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return this.checkGroups(exposeMetadata.options.groups);\n                });\n            }\n            else {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return (!exposeMetadata ||\n                        !exposeMetadata.options ||\n                        !exposeMetadata.options.groups ||\n                        !exposeMetadata.options.groups.length);\n                });\n            }\n        }\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {\n                return key.substr(0, prefix.length) !== prefix;\n            }));\n        }\n        // make sure we have unique keys\n        keys = keys.filter((key, index, self) => {\n            return self.indexOf(key) === index;\n        });\n        return keys;\n    }\n    checkVersion(since, until) {\n        let decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n        return decision;\n    }\n    checkGroups(groups) {\n        if (!groups)\n            return true;\n        return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,WAAW;AAClD,SAASC,kBAAkB,QAAQ,SAAS;AAC5C,SAASC,SAAS,EAAEC,SAAS,QAAQ,SAAS;AAC9C,SAASC,oBAAoBA,CAACC,SAAS,EAAE;EACrC,MAAMC,KAAK,GAAG,IAAID,SAAS,CAAC,CAAC;EAC7B,IAAI,EAAEC,KAAK,YAAYC,GAAG,CAAC,IAAI,EAAE,MAAM,IAAID,KAAK,CAAC,EAAE;IAC/C,OAAO,EAAE;EACb;EACA,OAAOA,KAAK;AAChB;AACA,OAAO,MAAME,0BAA0B,CAAC;EACpC;EACA;EACA;EACAC,WAAWA,CAACC,kBAAkB,EAAEC,OAAO,EAAE;IACrC,IAAI,CAACD,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB;IACA;IACA;IACA,IAAI,CAACC,cAAc,GAAG,IAAIL,GAAG,CAAC,CAAC;EACnC;EACA;EACA;EACA;EACAM,SAASA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEX,SAAS,EAAEY,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE;IAC9D,IAAIC,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,IAAIA,KAAK,YAAYR,GAAG,EAAE;MAC9C,MAAMc,QAAQ,GAAGhB,SAAS,IAAI,IAAI,CAACK,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,GACrFlB,oBAAoB,CAACC,SAAS,CAAC,GAC/B,EAAE;MACRU,KAAK,CAACQ,OAAO,CAAC,CAACC,QAAQ,EAAEC,KAAK,KAAK;QAC/B,MAAMC,SAAS,GAAGZ,MAAM,GAAGA,MAAM,CAACW,KAAK,CAAC,GAAGE,SAAS;QACpD,IAAI,CAAC,IAAI,CAAChB,OAAO,CAACiB,mBAAmB,IAAI,CAAC,IAAI,CAACC,UAAU,CAACL,QAAQ,CAAC,EAAE;UACjE,IAAIM,cAAc;UAClB,IAAI,OAAOd,UAAU,KAAK,UAAU,IAChCA,UAAU,IACVA,UAAU,CAACL,OAAO,IAClBK,UAAU,CAACL,OAAO,CAACoB,aAAa,IAChCf,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACC,QAAQ,IACzChB,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACE,QAAQ,EAAE;YAC3C,IAAI,IAAI,CAACvB,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;cAC/DQ,cAAc,GAAGd,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAKZ,QAAQ,CAACR,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC,CAAC;cAChJ,MAAMrB,OAAO,GAAG;gBAAE0B,SAAS,EAAEhB,QAAQ;gBAAEiB,MAAM,EAAEd,QAAQ;gBAAEQ,QAAQ,EAAEL;cAAU,CAAC;cAC9E,MAAMY,OAAO,GAAGvB,UAAU,CAACwB,YAAY,CAAC7B,OAAO,CAAC;cAChDmB,cAAc,KAAKH,SAAS,GAAIG,cAAc,GAAGS,OAAO,GAAKT,cAAc,GAAGA,cAAc,CAACf,KAAM;cACnG,IAAI,CAACC,UAAU,CAACL,OAAO,CAAC8B,yBAAyB,EAC7C,OAAOjB,QAAQ,CAACR,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC;YAClE;YACA,IAAI,IAAI,CAACtB,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,EAAE;cAC/DZ,cAAc,GAAGN,QAAQ,CAACf,WAAW;YACzC;YACA,IAAI,IAAI,CAACC,kBAAkB,KAAKT,kBAAkB,CAAC0C,cAAc,EAAE;cAC/DnB,QAAQ,CAACR,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC,GAAGhB,UAAU,CAACL,OAAO,CAACoB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACpB,KAAK,KAAKS,QAAQ,CAACf,WAAW,CAAC,CAAC2B,IAAI;YAChK;UACJ,CAAC,MACI;YACDN,cAAc,GAAGd,UAAU;UAC/B;UACA,MAAMD,KAAK,GAAG,IAAI,CAACF,SAAS,CAACa,SAAS,EAAEF,QAAQ,EAAEM,cAAc,EAAEH,SAAS,EAAEH,QAAQ,YAAYoB,GAAG,EAAE1B,KAAK,GAAG,CAAC,CAAC;UAChH,IAAIG,QAAQ,YAAYd,GAAG,EAAE;YACzBc,QAAQ,CAACwB,GAAG,CAAC9B,KAAK,CAAC;UACvB,CAAC,MACI;YACDM,QAAQ,CAACyB,IAAI,CAAC/B,KAAK,CAAC;UACxB;QACJ,CAAC,MACI,IAAI,IAAI,CAACL,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,EAAE;UACpE,IAAIrB,QAAQ,YAAYd,GAAG,EAAE;YACzBc,QAAQ,CAACwB,GAAG,CAACrB,QAAQ,CAAC;UAC1B,CAAC,MACI;YACDH,QAAQ,CAACyB,IAAI,CAACtB,QAAQ,CAAC;UAC3B;QACJ;MACJ,CAAC,CAAC;MACF,OAAOH,QAAQ;IACnB,CAAC,MACI,IAAIL,UAAU,KAAK+B,MAAM,IAAI,CAAC9B,KAAK,EAAE;MACtC,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKY,SAAS,EACrC,OAAOZ,KAAK;MAChB,OAAOgC,MAAM,CAAChC,KAAK,CAAC;IACxB,CAAC,MACI,IAAIC,UAAU,KAAKgC,MAAM,IAAI,CAAC/B,KAAK,EAAE;MACtC,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKY,SAAS,EACrC,OAAOZ,KAAK;MAChB,OAAOiC,MAAM,CAACjC,KAAK,CAAC;IACxB,CAAC,MACI,IAAIC,UAAU,KAAKiC,OAAO,IAAI,CAAChC,KAAK,EAAE;MACvC,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKY,SAAS,EACrC,OAAOZ,KAAK;MAChB,OAAOkC,OAAO,CAAClC,KAAK,CAAC;IACzB,CAAC,MACI,IAAI,CAACC,UAAU,KAAKkC,IAAI,IAAInC,KAAK,YAAYmC,IAAI,KAAK,CAACjC,KAAK,EAAE;MAC/D,IAAIF,KAAK,YAAYmC,IAAI,EAAE;QACvB,OAAO,IAAIA,IAAI,CAACnC,KAAK,CAACoC,OAAO,CAAC,CAAC,CAAC;MACpC;MACA,IAAIpC,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKY,SAAS,EACrC,OAAOZ,KAAK;MAChB,OAAO,IAAImC,IAAI,CAACnC,KAAK,CAAC;IAC1B,CAAC,MACI,IAAI,CAAC,CAACb,SAAS,CAAC,CAAC,CAACkD,MAAM,KAAKpC,UAAU,KAAKoC,MAAM,IAAIrC,KAAK,YAAYqC,MAAM,CAAC,IAAI,CAACnC,KAAK,EAAE;MAC3F,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKY,SAAS,EACrC,OAAOZ,KAAK;MAChB,OAAOqC,MAAM,CAACC,IAAI,CAACtC,KAAK,CAAC;IAC7B,CAAC,MACI,IAAIZ,SAAS,CAACY,KAAK,CAAC,IAAI,CAACE,KAAK,EAAE;MACjC,OAAO,IAAIqC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACpCzC,KAAK,CAAC0C,IAAI,CAAEC,IAAI,IAAKH,OAAO,CAAC,IAAI,CAAC1C,SAAS,CAACc,SAAS,EAAE+B,IAAI,EAAE1C,UAAU,EAAEW,SAAS,EAAEA,SAAS,EAAET,KAAK,GAAG,CAAC,CAAC,CAAC,EAAEsC,MAAM,CAAC;MACvH,CAAC,CAAC;IACN,CAAC,MACI,IAAI,CAACvC,KAAK,IAAIF,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAAC0C,IAAI,KAAK,UAAU,EAAE;MAChG;MACA;MACA,OAAO1C,KAAK,CAAC,CAAC;IAClB,CAAC,MACI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;MAClD;MACA,IAAI,CAACC,UAAU,IAAID,KAAK,CAACN,WAAW,KAAKkD,MAAM,CAAC,kEAC5C,IAAI,CAACxC,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,IAAIA,KAAK,CAACN,WAAW,KAAKU,KAAK,EAAE;QACtD;QACA;QACA;QACA;MAAA,CACH,MACI;QACD;QACAH,UAAU,GAAGD,KAAK,CAACN,WAAW;MAClC;MACJ,IAAI,CAACO,UAAU,IAAIF,MAAM,EACrBE,UAAU,GAAGF,MAAM,CAACL,WAAW;MACnC,IAAI,IAAI,CAACE,OAAO,CAACiB,mBAAmB,EAAE;QAClC;QACA,IAAI,CAAChB,cAAc,CAACiC,GAAG,CAAC9B,KAAK,CAAC;MAClC;MACA,MAAM6C,IAAI,GAAG,IAAI,CAACC,OAAO,CAAC7C,UAAU,EAAED,KAAK,EAAEE,KAAK,CAAC;MACnD,IAAII,QAAQ,GAAGP,MAAM,GAAGA,MAAM,GAAG,CAAC,CAAC;MACnC,IAAI,CAACA,MAAM,KACN,IAAI,CAACJ,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,IAC1D,IAAI,CAACZ,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,CAAC,EAAE;QACpE,IAAIzB,KAAK,EAAE;UACPI,QAAQ,GAAG,IAAIuB,GAAG,CAAC,CAAC;QACxB,CAAC,MACI,IAAI5B,UAAU,EAAE;UACjBK,QAAQ,GAAG,IAAIL,UAAU,CAAC,CAAC;QAC/B,CAAC,MACI;UACDK,QAAQ,GAAG,CAAC,CAAC;QACjB;MACJ;MACA;MACA,KAAK,MAAMyC,GAAG,IAAIF,IAAI,EAAE;QACpB,IAAIE,GAAG,KAAK,WAAW,IAAIA,GAAG,KAAK,aAAa,EAAE;UAC9C;QACJ;QACA,MAAMC,QAAQ,GAAGD,GAAG;QACpB,IAAIE,WAAW,GAAGF,GAAG;UAAEG,YAAY,GAAGH,GAAG;QACzC,IAAI,CAAC,IAAI,CAACnD,OAAO,CAACuD,gBAAgB,IAAIlD,UAAU,EAAE;UAC9C,IAAI,IAAI,CAACN,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;YAC/D,MAAM6C,cAAc,GAAGnE,sBAAsB,CAACoE,8BAA8B,CAACpD,UAAU,EAAE8C,GAAG,CAAC;YAC7F,IAAIK,cAAc,EAAE;cAChBF,YAAY,GAAGE,cAAc,CAACF,YAAY;cAC1CD,WAAW,GAAGG,cAAc,CAACF,YAAY;YAC7C;UACJ,CAAC,MACI,IAAI,IAAI,CAACvD,kBAAkB,KAAKT,kBAAkB,CAAC0C,cAAc,IAClE,IAAI,CAACjC,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,EAAE;YAC/D,MAAMyB,cAAc,GAAGnE,sBAAsB,CAACqE,kBAAkB,CAACrD,UAAU,EAAE8C,GAAG,CAAC;YACjF,IAAIK,cAAc,IAAIA,cAAc,CAACxD,OAAO,IAAIwD,cAAc,CAACxD,OAAO,CAACyB,IAAI,EAAE;cACzE4B,WAAW,GAAGG,cAAc,CAACxD,OAAO,CAACyB,IAAI;YAC7C;UACJ;QACJ;QACA;QACA,IAAIZ,QAAQ,GAAGG,SAAS;QACxB,IAAI,IAAI,CAACjB,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;UAC/D;AACpB;AACA;AACA;AACA;AACA;UACoBE,QAAQ,GAAGT,KAAK,CAACgD,QAAQ,CAAC;QAC9B,CAAC,MACI;UACD,IAAIhD,KAAK,YAAY6B,GAAG,EAAE;YACtBpB,QAAQ,GAAGT,KAAK,CAACuD,GAAG,CAACP,QAAQ,CAAC;UAClC,CAAC,MACI,IAAIhD,KAAK,CAACgD,QAAQ,CAAC,YAAYQ,QAAQ,EAAE;YAC1C/C,QAAQ,GAAGT,KAAK,CAACgD,QAAQ,CAAC,CAAC,CAAC;UAChC,CAAC,MACI;YACDvC,QAAQ,GAAGT,KAAK,CAACgD,QAAQ,CAAC;UAC9B;QACJ;QACA;QACA,IAAIS,IAAI,GAAG7C,SAAS;UAAE8C,aAAa,GAAGjD,QAAQ,YAAYoB,GAAG;QAC7D,IAAI5B,UAAU,IAAIC,KAAK,EAAE;UACrBuD,IAAI,GAAGxD,UAAU;QACrB,CAAC,MACI,IAAIA,UAAU,EAAE;UACjB,MAAM0D,QAAQ,GAAG1E,sBAAsB,CAAC2E,gBAAgB,CAAC3D,UAAU,EAAEiD,YAAY,CAAC;UAClF,IAAIS,QAAQ,EAAE;YACV,MAAM/D,OAAO,GAAG;cAAE0B,SAAS,EAAEhB,QAAQ;cAAEiB,MAAM,EAAEvB,KAAK;cAAEiB,QAAQ,EAAEiC;YAAa,CAAC;YAC9E,MAAM1B,OAAO,GAAGmC,QAAQ,CAAClC,YAAY,GAAGkC,QAAQ,CAAClC,YAAY,CAAC7B,OAAO,CAAC,GAAG+D,QAAQ,CAACE,aAAa;YAC/F,IAAIF,QAAQ,CAAC/D,OAAO,IAChB+D,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,IAC9B2C,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,IACvC0C,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACE,QAAQ,EAAE;cACzC,IAAI,EAAElB,KAAK,CAACgD,QAAQ,CAAC,YAAY5C,KAAK,CAAC,EAAE;gBACrC,IAAI,IAAI,CAACT,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;kBAC/DkD,IAAI,GAAGE,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAACC,OAAO,IAAI;oBAC3D,IAAIX,QAAQ,IAAIA,QAAQ,YAAYmC,MAAM,IAAIe,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,IAAIR,QAAQ,EAAE;sBAC/F,OAAOW,OAAO,CAACC,IAAI,KAAKZ,QAAQ,CAACkD,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC;oBAC7E;kBACJ,CAAC,CAAC;kBACFwC,IAAI,KAAK7C,SAAS,GAAI6C,IAAI,GAAGjC,OAAO,GAAKiC,IAAI,GAAGA,IAAI,CAACzD,KAAM;kBAC3D,IAAI,CAAC2D,QAAQ,CAAC/D,OAAO,CAAC8B,yBAAyB,EAAE;oBAC7C,IAAIjB,QAAQ,IAAIA,QAAQ,YAAYmC,MAAM,IAAIe,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,IAAIR,QAAQ,EAAE;sBAC/F,OAAOA,QAAQ,CAACkD,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC;oBAC5D;kBACJ;gBACJ;gBACA,IAAI,IAAI,CAACtB,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,EAAE;kBAC/D8B,IAAI,GAAGhD,QAAQ,CAACf,WAAW;gBAC/B;gBACA,IAAI,IAAI,CAACC,kBAAkB,KAAKT,kBAAkB,CAAC0C,cAAc,EAAE;kBAC/D,IAAInB,QAAQ,EAAE;oBACVA,QAAQ,CAACkD,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACC,QAAQ,CAAC,GAAG0C,QAAQ,CAAC/D,OAAO,CAACoB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACpB,KAAK,KAAKS,QAAQ,CAACf,WAAW,CAAC,CAAC2B,IAAI;kBAC5J;gBACJ;cACJ,CAAC,MACI;gBACDoC,IAAI,GAAGE,QAAQ;cACnB;YACJ,CAAC,MACI;cACDF,IAAI,GAAGjC,OAAO;YAClB;YACAkC,aAAa,GAAGA,aAAa,IAAIC,QAAQ,CAACE,aAAa,KAAKhC,GAAG;UACnE,CAAC,MACI,IAAI,IAAI,CAACjC,OAAO,CAACkE,UAAU,EAAE;YAC9B;YACA,IAAI,CAAClE,OAAO,CAACkE,UAAU,CAClBC,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAKhE,UAAU,IAAI,CAAC,CAAC+D,GAAG,CAACE,UAAU,CAAChB,YAAY,CAAC,CAAC,CAC1E1C,OAAO,CAACwD,GAAG,IAAKP,IAAI,GAAGO,GAAG,CAACE,UAAU,CAAChB,YAAY,CAAE,CAAC;UAC9D,CAAC,MACI,IAAI,IAAI,CAACtD,OAAO,CAACuE,wBAAwB,IAC1C,IAAI,CAACxE,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;YAC/D;YACA;YACA,MAAMsD,aAAa,GAAGO,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEpE,UAAU,CAACqE,SAAS,EAAEpB,YAAY,CAAC;YAC5F,IAAIW,aAAa,EAAE;cACfJ,IAAI,GAAGI,aAAa;YACxB;UACJ;QACJ;QACA;QACA,MAAMvE,SAAS,GAAGc,KAAK,CAACC,OAAO,CAACL,KAAK,CAACgD,QAAQ,CAAC,CAAC,GAC1C,IAAI,CAACuB,gBAAgB,CAACtE,UAAU,EAAEiD,YAAY,CAAC,GAC/CtC,SAAS;QACf;QACA,MAAMD,SAAS,GAAGZ,MAAM,GAAGA,MAAM,CAACiD,QAAQ,CAAC,GAAGpC,SAAS;QACvD;QACA;QACA;QACA;QACA;QACA,IAAIN,QAAQ,CAACZ,WAAW,CAAC4E,SAAS,EAAE;UAChC,MAAME,UAAU,GAAG5B,MAAM,CAAC6B,wBAAwB,CAACnE,QAAQ,CAACZ,WAAW,CAAC4E,SAAS,EAAErB,WAAW,CAAC;UAC/F,IAAI,CAAC,IAAI,CAACtD,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,IAC9D,IAAI,CAACZ,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc;UAC7D;UACE6C,UAAU,IAAI,CAACA,UAAU,CAACE,GAAG,IAAKpE,QAAQ,CAAC2C,WAAW,CAAC,YAAYO,QAAQ,CAAC;YAC9E;YACA;QACR;QACA,IAAI,CAAC,IAAI,CAAC5D,OAAO,CAACiB,mBAAmB,IAAI,CAAC,IAAI,CAACC,UAAU,CAACL,QAAQ,CAAC,EAAE;UACjE,MAAMkE,YAAY,GAAG,IAAI,CAAChF,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,GAAG0C,WAAW,GAAGF,GAAG;UACtG,IAAI6B,UAAU;UACd,IAAI,IAAI,CAACjF,kBAAkB,KAAKT,kBAAkB,CAAC0C,cAAc,EAAE;YAC/D;YACAgD,UAAU,GAAG5E,KAAK,CAAC2E,YAAY,CAAC;YAChC;YACAC,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAACD,UAAU,EAAE3E,UAAU,EAAE0E,YAAY,EAAE3E,KAAK,EAAE,IAAI,CAACL,kBAAkB,CAAC;YAClH;YACAiF,UAAU,GAAG5E,KAAK,CAAC2E,YAAY,CAAC,KAAKC,UAAU,GAAGnE,QAAQ,GAAGmE,UAAU;YACvE;YACAA,UAAU,GAAG,IAAI,CAAC9E,SAAS,CAACa,SAAS,EAAEiE,UAAU,EAAEnB,IAAI,EAAEnE,SAAS,EAAEoE,aAAa,EAAEvD,KAAK,GAAG,CAAC,CAAC;UACjG,CAAC,MACI;YACD,IAAIM,QAAQ,KAAKG,SAAS,IAAI,IAAI,CAAChB,OAAO,CAACkF,mBAAmB,EAAE;cAC5D;cACAF,UAAU,GAAGtE,QAAQ,CAAC2C,WAAW,CAAC;YACtC,CAAC,MACI;cACD2B,UAAU,GAAG,IAAI,CAAC9E,SAAS,CAACa,SAAS,EAAEF,QAAQ,EAAEgD,IAAI,EAAEnE,SAAS,EAAEoE,aAAa,EAAEvD,KAAK,GAAG,CAAC,CAAC;cAC3FyE,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAACD,UAAU,EAAE3E,UAAU,EAAE0E,YAAY,EAAE3E,KAAK,EAAE,IAAI,CAACL,kBAAkB,CAAC;YACtH;UACJ;UACA,IAAIiF,UAAU,KAAKhE,SAAS,IAAI,IAAI,CAAChB,OAAO,CAACmF,iBAAiB,EAAE;YAC5D,IAAIzE,QAAQ,YAAYuB,GAAG,EAAE;cACzBvB,QAAQ,CAACoE,GAAG,CAACzB,WAAW,EAAE2B,UAAU,CAAC;YACzC,CAAC,MACI;cACDtE,QAAQ,CAAC2C,WAAW,CAAC,GAAG2B,UAAU;YACtC;UACJ;QACJ,CAAC,MACI,IAAI,IAAI,CAACjF,kBAAkB,KAAKT,kBAAkB,CAACyC,cAAc,EAAE;UACpE,IAAIiD,UAAU,GAAGnE,QAAQ;UACzBmE,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAACD,UAAU,EAAE3E,UAAU,EAAE8C,GAAG,EAAE/C,KAAK,EAAE,IAAI,CAACL,kBAAkB,CAAC;UACzG,IAAIiF,UAAU,KAAKhE,SAAS,IAAI,IAAI,CAAChB,OAAO,CAACmF,iBAAiB,EAAE;YAC5D,IAAIzE,QAAQ,YAAYuB,GAAG,EAAE;cACzBvB,QAAQ,CAACoE,GAAG,CAACzB,WAAW,EAAE2B,UAAU,CAAC;YACzC,CAAC,MACI;cACDtE,QAAQ,CAAC2C,WAAW,CAAC,GAAG2B,UAAU;YACtC;UACJ;QACJ;MACJ;MACA,IAAI,IAAI,CAAChF,OAAO,CAACiB,mBAAmB,EAAE;QAClC,IAAI,CAAChB,cAAc,CAACmF,MAAM,CAAChF,KAAK,CAAC;MACrC;MACA,OAAOM,QAAQ;IACnB,CAAC,MACI;MACD,OAAON,KAAK;IAChB;EACJ;EACA6E,0BAA0BA,CAAC7E,KAAK,EAAEiE,MAAM,EAAElB,GAAG,EAAEkC,GAAG,EAAEtF,kBAAkB,EAAE;IACpE,IAAIuF,SAAS,GAAGjG,sBAAsB,CAACkG,sBAAsB,CAAClB,MAAM,EAAElB,GAAG,EAAE,IAAI,CAACpD,kBAAkB,CAAC;IACnG;IACA,IAAI,IAAI,CAACC,OAAO,CAACwF,OAAO,KAAKxE,SAAS,EAAE;MACpCsE,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAI;QACrC,IAAI,CAACA,QAAQ,CAAC/D,OAAO,EACjB,OAAO,IAAI;QACf,OAAO,IAAI,CAACyF,YAAY,CAAC1B,QAAQ,CAAC/D,OAAO,CAAC0F,KAAK,EAAE3B,QAAQ,CAAC/D,OAAO,CAAC2F,KAAK,CAAC;MAC5E,CAAC,CAAC;IACN;IACA;IACA,IAAI,IAAI,CAAC3F,OAAO,CAAC4F,MAAM,IAAI,IAAI,CAAC5F,OAAO,CAAC4F,MAAM,CAACC,MAAM,EAAE;MACnDP,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAI;QACrC,IAAI,CAACA,QAAQ,CAAC/D,OAAO,EACjB,OAAO,IAAI;QACf,OAAO,IAAI,CAAC8F,WAAW,CAAC/B,QAAQ,CAAC/D,OAAO,CAAC4F,MAAM,CAAC;MACpD,CAAC,CAAC;IACN,CAAC,MACI;MACDN,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAI;QACrC,OAAO,CAACA,QAAQ,CAAC/D,OAAO,IAAI,CAAC+D,QAAQ,CAAC/D,OAAO,CAAC4F,MAAM,IAAI,CAAC7B,QAAQ,CAAC/D,OAAO,CAAC4F,MAAM,CAACC,MAAM;MAC3F,CAAC,CAAC;IACN;IACAP,SAAS,CAAC1E,OAAO,CAACmD,QAAQ,IAAI;MAC1B3D,KAAK,GAAG2D,QAAQ,CAACgC,WAAW,CAAC;QAAE3F,KAAK;QAAE+C,GAAG;QAAEkC,GAAG;QAAExB,IAAI,EAAE9D,kBAAkB;QAAEC,OAAO,EAAE,IAAI,CAACA;MAAQ,CAAC,CAAC;IACtG,CAAC,CAAC;IACF,OAAOI,KAAK;EAChB;EACA;EACAc,UAAUA,CAACS,MAAM,EAAE;IACf,OAAO,IAAI,CAAC1B,cAAc,CAAC+F,GAAG,CAACrE,MAAM,CAAC;EAC1C;EACAgD,gBAAgBA,CAACN,MAAM,EAAEf,YAAY,EAAE;IACnC,IAAI,CAACe,MAAM,EACP,OAAOrD,SAAS;IACpB,MAAMiF,IAAI,GAAG5G,sBAAsB,CAAC2E,gBAAgB,CAACK,MAAM,EAAEf,YAAY,CAAC;IAC1E,OAAO2C,IAAI,GAAGA,IAAI,CAAChC,aAAa,GAAGjD,SAAS;EAChD;EACAkC,OAAOA,CAACmB,MAAM,EAAE1C,MAAM,EAAErB,KAAK,EAAE;IAC3B;IACA,IAAI4F,QAAQ,GAAG7G,sBAAsB,CAAC8G,WAAW,CAAC9B,MAAM,CAAC;IACzD,IAAI6B,QAAQ,KAAK,MAAM,EACnBA,QAAQ,GAAG,IAAI,CAAClG,OAAO,CAACkG,QAAQ,IAAI,WAAW,CAAC,CAAC;IACrD;IACA,IAAIjD,IAAI,GAAG,EAAE;IACb,IAAIiD,QAAQ,KAAK,WAAW,IAAI5F,KAAK,EAAE;MACnC,IAAIqB,MAAM,YAAYM,GAAG,EAAE;QACvBgB,IAAI,GAAGzC,KAAK,CAACkC,IAAI,CAACf,MAAM,CAACsB,IAAI,CAAC,CAAC,CAAC;MACpC,CAAC,MACI;QACDA,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACtB,MAAM,CAAC;MAC9B;IACJ;IACA,IAAIrB,KAAK,EAAE;MACP;MACA,OAAO2C,IAAI;IACf;IACA;AACR;AACA;AACA;IACQ,IAAI,IAAI,CAACjD,OAAO,CAACuD,gBAAgB,IAAI,IAAI,CAACvD,OAAO,CAACoG,uBAAuB,IAAI/B,MAAM,EAAE;MACjF,MAAMgC,iBAAiB,GAAGhH,sBAAsB,CAACiH,oBAAoB,CAACjC,MAAM,EAAE,IAAI,CAACtE,kBAAkB,CAAC;MACtG,MAAMwG,kBAAkB,GAAGlH,sBAAsB,CAACmH,qBAAqB,CAACnC,MAAM,EAAE,IAAI,CAACtE,kBAAkB,CAAC;MACxGkD,IAAI,GAAG,CAAC,GAAGoD,iBAAiB,EAAE,GAAGE,kBAAkB,CAAC;IACxD;IACA,IAAI,CAAC,IAAI,CAACvG,OAAO,CAACuD,gBAAgB,IAAIc,MAAM,EAAE;MAC1C;MACA,IAAIgC,iBAAiB,GAAGhH,sBAAsB,CAACiH,oBAAoB,CAACjC,MAAM,EAAE,IAAI,CAACtE,kBAAkB,CAAC;MACpG,IAAI,IAAI,CAACA,kBAAkB,KAAKT,kBAAkB,CAACqB,cAAc,EAAE;QAC/D0F,iBAAiB,GAAGA,iBAAiB,CAACjC,GAAG,CAACjB,GAAG,IAAI;UAC7C,MAAMK,cAAc,GAAGnE,sBAAsB,CAACqE,kBAAkB,CAACW,MAAM,EAAElB,GAAG,CAAC;UAC7E,IAAIK,cAAc,IAAIA,cAAc,CAACxD,OAAO,IAAIwD,cAAc,CAACxD,OAAO,CAACyB,IAAI,EAAE;YACzE,OAAO+B,cAAc,CAACxD,OAAO,CAACyB,IAAI;UACtC;UACA,OAAO0B,GAAG;QACd,CAAC,CAAC;MACN;MACA,IAAI,IAAI,CAACnD,OAAO,CAACoG,uBAAuB,EAAE;QACtCnD,IAAI,GAAGoD,iBAAiB;MAC5B,CAAC,MACI;QACDpD,IAAI,GAAGA,IAAI,CAACwD,MAAM,CAACJ,iBAAiB,CAAC;MACzC;MACA;MACA,MAAME,kBAAkB,GAAGlH,sBAAsB,CAACmH,qBAAqB,CAACnC,MAAM,EAAE,IAAI,CAACtE,kBAAkB,CAAC;MACxG,IAAIwG,kBAAkB,CAACV,MAAM,GAAG,CAAC,EAAE;QAC/B5C,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAChB,GAAG,IAAI;UACtB,OAAO,CAACoD,kBAAkB,CAACG,QAAQ,CAACvD,GAAG,CAAC;QAC5C,CAAC,CAAC;MACN;MACA;MACA,IAAI,IAAI,CAACnD,OAAO,CAACwF,OAAO,KAAKxE,SAAS,EAAE;QACpCiC,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAChB,GAAG,IAAI;UACtB,MAAMK,cAAc,GAAGnE,sBAAsB,CAACqE,kBAAkB,CAACW,MAAM,EAAElB,GAAG,CAAC;UAC7E,IAAI,CAACK,cAAc,IAAI,CAACA,cAAc,CAACxD,OAAO,EAC1C,OAAO,IAAI;UACf,OAAO,IAAI,CAACyF,YAAY,CAACjC,cAAc,CAACxD,OAAO,CAAC0F,KAAK,EAAElC,cAAc,CAACxD,OAAO,CAAC2F,KAAK,CAAC;QACxF,CAAC,CAAC;MACN;MACA;MACA,IAAI,IAAI,CAAC3F,OAAO,CAAC4F,MAAM,IAAI,IAAI,CAAC5F,OAAO,CAAC4F,MAAM,CAACC,MAAM,EAAE;QACnD5C,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAChB,GAAG,IAAI;UACtB,MAAMK,cAAc,GAAGnE,sBAAsB,CAACqE,kBAAkB,CAACW,MAAM,EAAElB,GAAG,CAAC;UAC7E,IAAI,CAACK,cAAc,IAAI,CAACA,cAAc,CAACxD,OAAO,EAC1C,OAAO,IAAI;UACf,OAAO,IAAI,CAAC8F,WAAW,CAACtC,cAAc,CAACxD,OAAO,CAAC4F,MAAM,CAAC;QAC1D,CAAC,CAAC;MACN,CAAC,MACI;QACD3C,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAChB,GAAG,IAAI;UACtB,MAAMK,cAAc,GAAGnE,sBAAsB,CAACqE,kBAAkB,CAACW,MAAM,EAAElB,GAAG,CAAC;UAC7E,OAAQ,CAACK,cAAc,IACnB,CAACA,cAAc,CAACxD,OAAO,IACvB,CAACwD,cAAc,CAACxD,OAAO,CAAC4F,MAAM,IAC9B,CAACpC,cAAc,CAACxD,OAAO,CAAC4F,MAAM,CAACC,MAAM;QAC7C,CAAC,CAAC;MACN;IACJ;IACA;IACA,IAAI,IAAI,CAAC7F,OAAO,CAAC2G,eAAe,IAAI,IAAI,CAAC3G,OAAO,CAAC2G,eAAe,CAACd,MAAM,EAAE;MACrE5C,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAChB,GAAG,IAAI,IAAI,CAACnD,OAAO,CAAC2G,eAAe,CAACC,KAAK,CAACC,MAAM,IAAI;QACnE,OAAO1D,GAAG,CAAC2D,MAAM,CAAC,CAAC,EAAED,MAAM,CAAChB,MAAM,CAAC,KAAKgB,MAAM;MAClD,CAAC,CAAC,CAAC;IACP;IACA;IACA5D,IAAI,GAAGA,IAAI,CAACkB,MAAM,CAAC,CAAChB,GAAG,EAAErC,KAAK,EAAEiG,IAAI,KAAK;MACrC,OAAOA,IAAI,CAACC,OAAO,CAAC7D,GAAG,CAAC,KAAKrC,KAAK;IACtC,CAAC,CAAC;IACF,OAAOmC,IAAI;EACf;EACAwC,YAAYA,CAACC,KAAK,EAAEC,KAAK,EAAE;IACvB,IAAIsB,QAAQ,GAAG,IAAI;IACnB,IAAIA,QAAQ,IAAIvB,KAAK,EACjBuB,QAAQ,GAAG,IAAI,CAACjH,OAAO,CAACwF,OAAO,IAAIE,KAAK;IAC5C,IAAIuB,QAAQ,IAAItB,KAAK,EACjBsB,QAAQ,GAAG,IAAI,CAACjH,OAAO,CAACwF,OAAO,GAAGG,KAAK;IAC3C,OAAOsB,QAAQ;EACnB;EACAnB,WAAWA,CAACF,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,EACP,OAAO,IAAI;IACf,OAAO,IAAI,CAAC5F,OAAO,CAAC4F,MAAM,CAACsB,IAAI,CAACC,WAAW,IAAIvB,MAAM,CAACc,QAAQ,CAACS,WAAW,CAAC,CAAC;EAChF;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
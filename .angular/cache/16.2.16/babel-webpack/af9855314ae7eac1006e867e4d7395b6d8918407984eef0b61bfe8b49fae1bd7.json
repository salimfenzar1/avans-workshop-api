{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterExplorer = void 0;\nconst constants_1 = require(\"@nestjs/common/constants\");\nconst enums_1 = require(\"@nestjs/common/enums\");\nconst exceptions_1 = require(\"@nestjs/common/exceptions\");\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst pathToRegexp = require(\"path-to-regexp\");\nconst unknown_request_mapping_exception_1 = require(\"../errors/exceptions/unknown-request-mapping.exception\");\nconst guards_1 = require(\"../guards\");\nconst context_id_factory_1 = require(\"../helpers/context-id-factory\");\nconst execution_context_host_1 = require(\"../helpers/execution-context-host\");\nconst messages_1 = require(\"../helpers/messages\");\nconst router_method_factory_1 = require(\"../helpers/router-method-factory\");\nconst constants_2 = require(\"../injector/constants\");\nconst interceptors_1 = require(\"../interceptors\");\nconst pipes_1 = require(\"../pipes\");\nconst paths_explorer_1 = require(\"./paths-explorer\");\nconst request_constants_1 = require(\"./request/request-constants\");\nconst route_params_factory_1 = require(\"./route-params-factory\");\nconst router_execution_context_1 = require(\"./router-execution-context\");\nclass RouterExplorer {\n  constructor(metadataScanner, container, injector, routerProxy, exceptionsFilter, config, routePathFactory, graphInspector) {\n    this.container = container;\n    this.injector = injector;\n    this.routerProxy = routerProxy;\n    this.exceptionsFilter = exceptionsFilter;\n    this.routePathFactory = routePathFactory;\n    this.graphInspector = graphInspector;\n    this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();\n    this.logger = new logger_service_1.Logger(RouterExplorer.name, {\n      timestamp: true\n    });\n    this.exceptionFiltersCache = new WeakMap();\n    this.pathsExplorer = new paths_explorer_1.PathsExplorer(metadataScanner);\n    const routeParamsFactory = new route_params_factory_1.RouteParamsFactory();\n    const pipesContextCreator = new pipes_1.PipesContextCreator(container, config);\n    const pipesConsumer = new pipes_1.PipesConsumer();\n    const guardsContextCreator = new guards_1.GuardsContextCreator(container, config);\n    const guardsConsumer = new guards_1.GuardsConsumer();\n    const interceptorsContextCreator = new interceptors_1.InterceptorsContextCreator(container, config);\n    const interceptorsConsumer = new interceptors_1.InterceptorsConsumer();\n    this.executionContextCreator = new router_execution_context_1.RouterExecutionContext(routeParamsFactory, pipesContextCreator, pipesConsumer, guardsContextCreator, guardsConsumer, interceptorsContextCreator, interceptorsConsumer, container.getHttpAdapterRef());\n  }\n  explore(instanceWrapper, moduleKey, applicationRef, host, routePathMetadata) {\n    const {\n      instance\n    } = instanceWrapper;\n    const routerPaths = this.pathsExplorer.scanForPaths(instance);\n    this.applyPathsToRouterProxy(applicationRef, routerPaths, instanceWrapper, moduleKey, routePathMetadata, host);\n  }\n  extractRouterPath(metatype) {\n    const path = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);\n    if ((0, shared_utils_1.isUndefined)(path)) {\n      throw new unknown_request_mapping_exception_1.UnknownRequestMappingException(metatype);\n    }\n    if (Array.isArray(path)) {\n      return path.map(p => (0, shared_utils_1.addLeadingSlash)(p));\n    }\n    return [(0, shared_utils_1.addLeadingSlash)(path)];\n  }\n  applyPathsToRouterProxy(router, routeDefinitions, instanceWrapper, moduleKey, routePathMetadata, host) {\n    (routeDefinitions || []).forEach(routeDefinition => {\n      const {\n        version: methodVersion\n      } = routeDefinition;\n      routePathMetadata.methodVersion = methodVersion;\n      this.applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host);\n    });\n  }\n  applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host) {\n    const {\n      path: paths,\n      requestMethod,\n      targetCallback,\n      methodName\n    } = routeDefinition;\n    const {\n      instance\n    } = instanceWrapper;\n    const routerMethodRef = this.routerMethodFactory.get(router, requestMethod).bind(router);\n    const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n    const proxy = isRequestScoped ? this.createRequestScopedHandler(instanceWrapper, requestMethod, this.container.getModuleByKey(moduleKey), moduleKey, methodName) : this.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n    const isVersioned = (routePathMetadata.methodVersion || routePathMetadata.controllerVersion) && routePathMetadata.versioningOptions;\n    let routeHandler = this.applyHostFilter(host, proxy);\n    paths.forEach(path => {\n      if (isVersioned && routePathMetadata.versioningOptions.type !== enums_1.VersioningType.URI) {\n        // All versioning (except for URI Versioning) is done via the \"Version Filter\"\n        routeHandler = this.applyVersionFilter(router, routePathMetadata, routeHandler);\n      }\n      routePathMetadata.methodPath = path;\n      const pathsToRegister = this.routePathFactory.create(routePathMetadata, requestMethod);\n      pathsToRegister.forEach(path => {\n        const entrypointDefinition = {\n          type: 'http-endpoint',\n          methodName,\n          className: instanceWrapper.name,\n          classNodeId: instanceWrapper.id,\n          metadata: {\n            key: path,\n            path,\n            requestMethod: enums_1.RequestMethod[requestMethod],\n            methodVersion: routePathMetadata.methodVersion,\n            controllerVersion: routePathMetadata.controllerVersion\n          }\n        };\n        this.copyMetadataToCallback(targetCallback, routeHandler);\n        routerMethodRef(path, routeHandler);\n        this.graphInspector.insertEntrypointDefinition(entrypointDefinition, instanceWrapper.id);\n      });\n      const pathsToLog = this.routePathFactory.create({\n        ...routePathMetadata,\n        versioningOptions: undefined\n      }, requestMethod);\n      pathsToLog.forEach(path => {\n        if (isVersioned) {\n          const version = this.routePathFactory.getVersion(routePathMetadata);\n          this.logger.log((0, messages_1.VERSIONED_ROUTE_MAPPED_MESSAGE)(path, requestMethod, version));\n        } else {\n          this.logger.log((0, messages_1.ROUTE_MAPPED_MESSAGE)(path, requestMethod));\n        }\n      });\n    });\n  }\n  applyHostFilter(host, handler) {\n    if (!host) {\n      return handler;\n    }\n    const httpAdapterRef = this.container.getHttpAdapterRef();\n    const hosts = Array.isArray(host) ? host : [host];\n    const hostRegExps = hosts.map(host => {\n      const keys = [];\n      const regexp = pathToRegexp(host, keys);\n      return {\n        regexp,\n        keys\n      };\n    });\n    const unsupportedFilteringErrorMessage = Array.isArray(host) ? `HTTP adapter does not support filtering on hosts: [\"${host.join('\", \"')}\"]` : `HTTP adapter does not support filtering on host: \"${host}\"`;\n    return (req, res, next) => {\n      req.hosts = {};\n      const hostname = httpAdapterRef.getRequestHostname(req) || '';\n      for (const exp of hostRegExps) {\n        const match = hostname.match(exp.regexp);\n        if (match) {\n          if (exp.keys.length > 0) {\n            exp.keys.forEach((key, i) => req.hosts[key.name] = match[i + 1]);\n          } else if (exp.regexp && match.groups) {\n            for (const groupName in match.groups) {\n              req.hosts[groupName] = match.groups[groupName];\n            }\n          }\n          return handler(req, res, next);\n        }\n      }\n      if (!next) {\n        throw new exceptions_1.InternalServerErrorException(unsupportedFilteringErrorMessage);\n      }\n      return next();\n    };\n  }\n  applyVersionFilter(router, routePathMetadata, handler) {\n    const version = this.routePathFactory.getVersion(routePathMetadata);\n    return router.applyVersionFilter(handler, version, routePathMetadata.versioningOptions);\n  }\n  createCallbackProxy(instance, callback, methodName, moduleRef, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {\n    const executionContext = this.executionContextCreator.create(instance, callback, methodName, moduleRef, requestMethod, contextId, inquirerId);\n    const exceptionFilter = this.exceptionsFilter.create(instance, callback, moduleRef, contextId, inquirerId);\n    return this.routerProxy.createProxy(executionContext, exceptionFilter);\n  }\n  createRequestScopedHandler(instanceWrapper, requestMethod, moduleRef, moduleKey, methodName) {\n    var _this = this;\n    const {\n      instance\n    } = instanceWrapper;\n    const collection = moduleRef.controllers;\n    const isTreeDurable = instanceWrapper.isDependencyTreeDurable();\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next) {\n        try {\n          const contextId = _this.getContextId(req, isTreeDurable);\n          const contextInstance = yield _this.injector.loadPerContext(instance, moduleRef, collection, contextId);\n          yield _this.createCallbackProxy(contextInstance, contextInstance[methodName], methodName, moduleKey, requestMethod, contextId, instanceWrapper.id)(req, res, next);\n        } catch (err) {\n          let exceptionFilter = _this.exceptionFiltersCache.get(instance[methodName]);\n          if (!exceptionFilter) {\n            exceptionFilter = _this.exceptionsFilter.create(instance, instance[methodName], moduleKey);\n            _this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);\n          }\n          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);\n          exceptionFilter.next(err, host);\n        }\n      });\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  getContextId(request, isTreeDurable) {\n    const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request);\n    if (!request[request_constants_1.REQUEST_CONTEXT_ID]) {\n      Object.defineProperty(request, request_constants_1.REQUEST_CONTEXT_ID, {\n        value: contextId,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      });\n      const requestProviderValue = isTreeDurable ? contextId.payload : request;\n      this.container.registerRequestProvider(requestProviderValue, contextId);\n    }\n    return contextId;\n  }\n  copyMetadataToCallback(originalCallback, targetCallback) {\n    for (const key of Reflect.getMetadataKeys(originalCallback)) {\n      Reflect.defineMetadata(key, Reflect.getMetadata(key, originalCallback), targetCallback);\n    }\n  }\n}\nexports.RouterExplorer = RouterExplorer;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","RouterExplorer","constants_1","enums_1","exceptions_1","logger_service_1","shared_utils_1","pathToRegexp","unknown_request_mapping_exception_1","guards_1","context_id_factory_1","execution_context_host_1","messages_1","router_method_factory_1","constants_2","interceptors_1","pipes_1","paths_explorer_1","request_constants_1","route_params_factory_1","router_execution_context_1","constructor","metadataScanner","container","injector","routerProxy","exceptionsFilter","config","routePathFactory","graphInspector","routerMethodFactory","RouterMethodFactory","logger","Logger","name","timestamp","exceptionFiltersCache","WeakMap","pathsExplorer","PathsExplorer","routeParamsFactory","RouteParamsFactory","pipesContextCreator","PipesContextCreator","pipesConsumer","PipesConsumer","guardsContextCreator","GuardsContextCreator","guardsConsumer","GuardsConsumer","interceptorsContextCreator","InterceptorsContextCreator","interceptorsConsumer","InterceptorsConsumer","executionContextCreator","RouterExecutionContext","getHttpAdapterRef","explore","instanceWrapper","moduleKey","applicationRef","host","routePathMetadata","instance","routerPaths","scanForPaths","applyPathsToRouterProxy","extractRouterPath","metatype","path","Reflect","getMetadata","PATH_METADATA","isUndefined","UnknownRequestMappingException","Array","isArray","map","p","addLeadingSlash","router","routeDefinitions","forEach","routeDefinition","version","methodVersion","applyCallbackToRouter","paths","requestMethod","targetCallback","methodName","routerMethodRef","get","bind","isRequestScoped","isDependencyTreeStatic","proxy","createRequestScopedHandler","getModuleByKey","createCallbackProxy","isVersioned","controllerVersion","versioningOptions","routeHandler","applyHostFilter","type","VersioningType","URI","applyVersionFilter","methodPath","pathsToRegister","create","entrypointDefinition","className","classNodeId","id","metadata","key","RequestMethod","copyMetadataToCallback","insertEntrypointDefinition","pathsToLog","undefined","getVersion","log","VERSIONED_ROUTE_MAPPED_MESSAGE","ROUTE_MAPPED_MESSAGE","handler","httpAdapterRef","hosts","hostRegExps","keys","regexp","unsupportedFilteringErrorMessage","join","req","res","next","hostname","getRequestHostname","exp","match","length","i","groups","groupName","InternalServerErrorException","callback","moduleRef","contextId","STATIC_CONTEXT","inquirerId","executionContext","exceptionFilter","createProxy","_this","collection","controllers","isTreeDurable","isDependencyTreeDurable","_ref","getContextId","contextInstance","loadPerContext","err","set","ExecutionContextHost","_x","_x2","_x3","apply","arguments","request","ContextIdFactory","getByRequest","REQUEST_CONTEXT_ID","enumerable","writable","configurable","requestProviderValue","payload","registerRequestProvider","originalCallback","getMetadataKeys","defineMetadata"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/core/router/router-explorer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RouterExplorer = void 0;\nconst constants_1 = require(\"@nestjs/common/constants\");\nconst enums_1 = require(\"@nestjs/common/enums\");\nconst exceptions_1 = require(\"@nestjs/common/exceptions\");\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst pathToRegexp = require(\"path-to-regexp\");\nconst unknown_request_mapping_exception_1 = require(\"../errors/exceptions/unknown-request-mapping.exception\");\nconst guards_1 = require(\"../guards\");\nconst context_id_factory_1 = require(\"../helpers/context-id-factory\");\nconst execution_context_host_1 = require(\"../helpers/execution-context-host\");\nconst messages_1 = require(\"../helpers/messages\");\nconst router_method_factory_1 = require(\"../helpers/router-method-factory\");\nconst constants_2 = require(\"../injector/constants\");\nconst interceptors_1 = require(\"../interceptors\");\nconst pipes_1 = require(\"../pipes\");\nconst paths_explorer_1 = require(\"./paths-explorer\");\nconst request_constants_1 = require(\"./request/request-constants\");\nconst route_params_factory_1 = require(\"./route-params-factory\");\nconst router_execution_context_1 = require(\"./router-execution-context\");\nclass RouterExplorer {\n    constructor(metadataScanner, container, injector, routerProxy, exceptionsFilter, config, routePathFactory, graphInspector) {\n        this.container = container;\n        this.injector = injector;\n        this.routerProxy = routerProxy;\n        this.exceptionsFilter = exceptionsFilter;\n        this.routePathFactory = routePathFactory;\n        this.graphInspector = graphInspector;\n        this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();\n        this.logger = new logger_service_1.Logger(RouterExplorer.name, {\n            timestamp: true,\n        });\n        this.exceptionFiltersCache = new WeakMap();\n        this.pathsExplorer = new paths_explorer_1.PathsExplorer(metadataScanner);\n        const routeParamsFactory = new route_params_factory_1.RouteParamsFactory();\n        const pipesContextCreator = new pipes_1.PipesContextCreator(container, config);\n        const pipesConsumer = new pipes_1.PipesConsumer();\n        const guardsContextCreator = new guards_1.GuardsContextCreator(container, config);\n        const guardsConsumer = new guards_1.GuardsConsumer();\n        const interceptorsContextCreator = new interceptors_1.InterceptorsContextCreator(container, config);\n        const interceptorsConsumer = new interceptors_1.InterceptorsConsumer();\n        this.executionContextCreator = new router_execution_context_1.RouterExecutionContext(routeParamsFactory, pipesContextCreator, pipesConsumer, guardsContextCreator, guardsConsumer, interceptorsContextCreator, interceptorsConsumer, container.getHttpAdapterRef());\n    }\n    explore(instanceWrapper, moduleKey, applicationRef, host, routePathMetadata) {\n        const { instance } = instanceWrapper;\n        const routerPaths = this.pathsExplorer.scanForPaths(instance);\n        this.applyPathsToRouterProxy(applicationRef, routerPaths, instanceWrapper, moduleKey, routePathMetadata, host);\n    }\n    extractRouterPath(metatype) {\n        const path = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);\n        if ((0, shared_utils_1.isUndefined)(path)) {\n            throw new unknown_request_mapping_exception_1.UnknownRequestMappingException(metatype);\n        }\n        if (Array.isArray(path)) {\n            return path.map(p => (0, shared_utils_1.addLeadingSlash)(p));\n        }\n        return [(0, shared_utils_1.addLeadingSlash)(path)];\n    }\n    applyPathsToRouterProxy(router, routeDefinitions, instanceWrapper, moduleKey, routePathMetadata, host) {\n        (routeDefinitions || []).forEach(routeDefinition => {\n            const { version: methodVersion } = routeDefinition;\n            routePathMetadata.methodVersion = methodVersion;\n            this.applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host);\n        });\n    }\n    applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host) {\n        const { path: paths, requestMethod, targetCallback, methodName, } = routeDefinition;\n        const { instance } = instanceWrapper;\n        const routerMethodRef = this.routerMethodFactory\n            .get(router, requestMethod)\n            .bind(router);\n        const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n        const proxy = isRequestScoped\n            ? this.createRequestScopedHandler(instanceWrapper, requestMethod, this.container.getModuleByKey(moduleKey), moduleKey, methodName)\n            : this.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n        const isVersioned = (routePathMetadata.methodVersion ||\n            routePathMetadata.controllerVersion) &&\n            routePathMetadata.versioningOptions;\n        let routeHandler = this.applyHostFilter(host, proxy);\n        paths.forEach(path => {\n            if (isVersioned &&\n                routePathMetadata.versioningOptions.type !== enums_1.VersioningType.URI) {\n                // All versioning (except for URI Versioning) is done via the \"Version Filter\"\n                routeHandler = this.applyVersionFilter(router, routePathMetadata, routeHandler);\n            }\n            routePathMetadata.methodPath = path;\n            const pathsToRegister = this.routePathFactory.create(routePathMetadata, requestMethod);\n            pathsToRegister.forEach(path => {\n                const entrypointDefinition = {\n                    type: 'http-endpoint',\n                    methodName,\n                    className: instanceWrapper.name,\n                    classNodeId: instanceWrapper.id,\n                    metadata: {\n                        key: path,\n                        path,\n                        requestMethod: enums_1.RequestMethod[requestMethod],\n                        methodVersion: routePathMetadata.methodVersion,\n                        controllerVersion: routePathMetadata.controllerVersion,\n                    },\n                };\n                this.copyMetadataToCallback(targetCallback, routeHandler);\n                routerMethodRef(path, routeHandler);\n                this.graphInspector.insertEntrypointDefinition(entrypointDefinition, instanceWrapper.id);\n            });\n            const pathsToLog = this.routePathFactory.create({\n                ...routePathMetadata,\n                versioningOptions: undefined,\n            }, requestMethod);\n            pathsToLog.forEach(path => {\n                if (isVersioned) {\n                    const version = this.routePathFactory.getVersion(routePathMetadata);\n                    this.logger.log((0, messages_1.VERSIONED_ROUTE_MAPPED_MESSAGE)(path, requestMethod, version));\n                }\n                else {\n                    this.logger.log((0, messages_1.ROUTE_MAPPED_MESSAGE)(path, requestMethod));\n                }\n            });\n        });\n    }\n    applyHostFilter(host, handler) {\n        if (!host) {\n            return handler;\n        }\n        const httpAdapterRef = this.container.getHttpAdapterRef();\n        const hosts = Array.isArray(host) ? host : [host];\n        const hostRegExps = hosts.map((host) => {\n            const keys = [];\n            const regexp = pathToRegexp(host, keys);\n            return { regexp, keys };\n        });\n        const unsupportedFilteringErrorMessage = Array.isArray(host)\n            ? `HTTP adapter does not support filtering on hosts: [\"${host.join('\", \"')}\"]`\n            : `HTTP adapter does not support filtering on host: \"${host}\"`;\n        return (req, res, next) => {\n            req.hosts = {};\n            const hostname = httpAdapterRef.getRequestHostname(req) || '';\n            for (const exp of hostRegExps) {\n                const match = hostname.match(exp.regexp);\n                if (match) {\n                    if (exp.keys.length > 0) {\n                        exp.keys.forEach((key, i) => (req.hosts[key.name] = match[i + 1]));\n                    }\n                    else if (exp.regexp && match.groups) {\n                        for (const groupName in match.groups) {\n                            req.hosts[groupName] = match.groups[groupName];\n                        }\n                    }\n                    return handler(req, res, next);\n                }\n            }\n            if (!next) {\n                throw new exceptions_1.InternalServerErrorException(unsupportedFilteringErrorMessage);\n            }\n            return next();\n        };\n    }\n    applyVersionFilter(router, routePathMetadata, handler) {\n        const version = this.routePathFactory.getVersion(routePathMetadata);\n        return router.applyVersionFilter(handler, version, routePathMetadata.versioningOptions);\n    }\n    createCallbackProxy(instance, callback, methodName, moduleRef, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {\n        const executionContext = this.executionContextCreator.create(instance, callback, methodName, moduleRef, requestMethod, contextId, inquirerId);\n        const exceptionFilter = this.exceptionsFilter.create(instance, callback, moduleRef, contextId, inquirerId);\n        return this.routerProxy.createProxy(executionContext, exceptionFilter);\n    }\n    createRequestScopedHandler(instanceWrapper, requestMethod, moduleRef, moduleKey, methodName) {\n        const { instance } = instanceWrapper;\n        const collection = moduleRef.controllers;\n        const isTreeDurable = instanceWrapper.isDependencyTreeDurable();\n        return async (req, res, next) => {\n            try {\n                const contextId = this.getContextId(req, isTreeDurable);\n                const contextInstance = await this.injector.loadPerContext(instance, moduleRef, collection, contextId);\n                await this.createCallbackProxy(contextInstance, contextInstance[methodName], methodName, moduleKey, requestMethod, contextId, instanceWrapper.id)(req, res, next);\n            }\n            catch (err) {\n                let exceptionFilter = this.exceptionFiltersCache.get(instance[methodName]);\n                if (!exceptionFilter) {\n                    exceptionFilter = this.exceptionsFilter.create(instance, instance[methodName], moduleKey);\n                    this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);\n                }\n                const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);\n                exceptionFilter.next(err, host);\n            }\n        };\n    }\n    getContextId(request, isTreeDurable) {\n        const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request);\n        if (!request[request_constants_1.REQUEST_CONTEXT_ID]) {\n            Object.defineProperty(request, request_constants_1.REQUEST_CONTEXT_ID, {\n                value: contextId,\n                enumerable: false,\n                writable: false,\n                configurable: false,\n            });\n            const requestProviderValue = isTreeDurable ? contextId.payload : request;\n            this.container.registerRequestProvider(requestProviderValue, contextId);\n        }\n        return contextId;\n    }\n    copyMetadataToCallback(originalCallback, targetCallback) {\n        for (const key of Reflect.getMetadataKeys(originalCallback)) {\n            Reflect.defineMetadata(key, Reflect.getMetadata(key, originalCallback), targetCallback);\n        }\n    }\n}\nexports.RouterExplorer = RouterExplorer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
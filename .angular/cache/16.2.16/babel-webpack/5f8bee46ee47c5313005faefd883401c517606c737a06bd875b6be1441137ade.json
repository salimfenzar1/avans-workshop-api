{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigurableModuleBuilder = void 0;\nconst logger_service_1 = require(\"../services/logger.service\");\nconst random_string_generator_util_1 = require(\"../utils/random-string-generator.util\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\n/**\n * Factory that lets you create configurable modules and\n * provides a way to reduce the majority of dynamic module boilerplate.\n *\n * @publicApi\n */\nclass ConfigurableModuleBuilder {\n  constructor(options = {}, parentBuilder) {\n    this.options = options;\n    this.logger = new logger_service_1.Logger(ConfigurableModuleBuilder.name);\n    if (parentBuilder) {\n      this.staticMethodKey = parentBuilder.staticMethodKey;\n      this.factoryClassMethodKey = parentBuilder.factoryClassMethodKey;\n      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\n      this.extras = parentBuilder.extras;\n    }\n  }\n  /**\n   * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\n   * Values you specify within the \"extras\" object will be used as default values (that can be overridden by module consumers).\n   *\n   * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\n   * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\n   * The \"extras\" object consists of values explicitly specified by module consumers and default values.\n   *\n   * @example\n   * ```typescript\n   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\n   *    ({ ...definition, global: extras.isGlobal })\n   * )\n   * ```\n   */\n  setExtras(extras, transformDefinition = def => def) {\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.extras = extras;\n    builder.transformModuleDefinition = transformDefinition;\n    return builder;\n  }\n  /**\n   * Dynamic modules must expose public static methods that let you pass in\n   * configuration parameters (control the module's behavior from the outside).\n   * Some frequently used names that you may have seen in other modules are:\n   * \"forRoot\", \"forFeature\", \"register\", \"configure\".\n   *\n   * This method \"setClassMethodName\" lets you specify the name of the\n   * method that will be auto-generated.\n   *\n   * @param key name of the method\n   */\n  setClassMethodName(key) {\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.staticMethodKey = key;\n    return builder;\n  }\n  /**\n   * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\n   * let you pass the configuration factory class that will be registered and instantiated as a provider.\n   * This provider then will be used to retrieve the module's configuration. To provide the configuration,\n   * the corresponding factory method must be implemented.\n   *\n   * This method (\"setFactoryMethodName\") lets you control what method name will have to be\n   * implemented by the config factory (default is \"create\").\n   *\n   * @param key name of the method\n   */\n  setFactoryMethodName(key) {\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.factoryClassMethodKey = key;\n    return builder;\n  }\n  /**\n   * Returns an object consisting of multiple properties that lets you\n   * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\n   */\n  build() {\n    this.staticMethodKey ??= constants_1.DEFAULT_METHOD_KEY;\n    this.factoryClassMethodKey ??= constants_1.DEFAULT_FACTORY_CLASS_METHOD_KEY;\n    this.options.optionsInjectionToken ??= this.options.moduleName ? this.constructInjectionTokenString() : (0, utils_1.generateOptionsInjectionToken)();\n    this.transformModuleDefinition ??= definition => definition;\n    return {\n      ConfigurableModuleClass: this.createConfigurableModuleCls(),\n      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\n      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\n      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE')\n    };\n  }\n  constructInjectionTokenString() {\n    const moduleNameInSnakeCase = this.options.moduleName.trim().split(/(?=[A-Z])/).join('_').toUpperCase();\n    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\n  }\n  createConfigurableModuleCls() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const asyncMethodKey = this.staticMethodKey + constants_1.ASYNC_METHOD_SUFFIX;\n    class InternalModuleClass {\n      static [self.staticMethodKey](options) {\n        const providers = [{\n          provide: self.options.optionsInjectionToken,\n          useValue: this.omitExtras(options, self.extras)\n        }];\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: constants_1.CONFIGURABLE_MODULE_ID,\n            useValue: (0, random_string_generator_util_1.randomStringGenerator)()\n          });\n        }\n        return self.transformModuleDefinition({\n          module: this,\n          providers\n        }, {\n          ...self.extras,\n          ...options\n        });\n      }\n      static [asyncMethodKey](options) {\n        const providers = this.createAsyncProviders(options);\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: constants_1.CONFIGURABLE_MODULE_ID,\n            useValue: (0, random_string_generator_util_1.randomStringGenerator)()\n          });\n        }\n        return self.transformModuleDefinition({\n          module: this,\n          imports: options.imports || [],\n          providers\n        }, {\n          ...self.extras,\n          ...options\n        });\n      }\n      static omitExtras(input, extras) {\n        if (!extras) {\n          return input;\n        }\n        const moduleOptions = {};\n        const extrasKeys = Object.keys(extras);\n        Object.keys(input).filter(key => !extrasKeys.includes(key)).forEach(key => {\n          moduleOptions[key] = input[key];\n        });\n        return moduleOptions;\n      }\n      static createAsyncProviders(options) {\n        if (options.useExisting || options.useFactory) {\n          if (options.inject && options.provideInjectionTokensFrom) {\n            return [this.createAsyncOptionsProvider(options), ...(0, utils_1.getInjectionProviders)(options.provideInjectionTokensFrom, options.inject)];\n          }\n          return [this.createAsyncOptionsProvider(options)];\n        }\n        return [this.createAsyncOptionsProvider(options), {\n          provide: options.useClass,\n          useClass: options.useClass\n        }];\n      }\n      static createAsyncOptionsProvider(options) {\n        if (options.useFactory) {\n          return {\n            provide: self.options.optionsInjectionToken,\n            useFactory: options.useFactory,\n            inject: options.inject || []\n          };\n        }\n        return {\n          provide: self.options.optionsInjectionToken,\n          useFactory: function () {\n            var _ref = _asyncToGenerator(function* (optionsFactory) {\n              return yield optionsFactory[self.factoryClassMethodKey]();\n            });\n            return function useFactory(_x) {\n              return _ref.apply(this, arguments);\n            };\n          }(),\n          inject: [options.useExisting || options.useClass]\n        };\n      }\n    }\n    return InternalModuleClass;\n  }\n  createTypeProxy(typeName) {\n    const proxy = new Proxy({}, {\n      get: () => {\n        throw new Error(`\"${typeName}\" is not supposed to be used as a value.`);\n      }\n    });\n    return proxy;\n  }\n}\nexports.ConfigurableModuleBuilder = ConfigurableModuleBuilder;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","ConfigurableModuleBuilder","logger_service_1","random_string_generator_util_1","constants_1","utils_1","constructor","options","parentBuilder","logger","Logger","name","staticMethodKey","factoryClassMethodKey","transformModuleDefinition","extras","setExtras","transformDefinition","def","builder","setClassMethodName","key","setFactoryMethodName","build","DEFAULT_METHOD_KEY","DEFAULT_FACTORY_CLASS_METHOD_KEY","optionsInjectionToken","moduleName","constructInjectionTokenString","generateOptionsInjectionToken","definition","ConfigurableModuleClass","createConfigurableModuleCls","MODULE_OPTIONS_TOKEN","ASYNC_OPTIONS_TYPE","createTypeProxy","OPTIONS_TYPE","moduleNameInSnakeCase","trim","split","join","toUpperCase","self","asyncMethodKey","ASYNC_METHOD_SUFFIX","InternalModuleClass","providers","provide","useValue","omitExtras","alwaysTransient","push","CONFIGURABLE_MODULE_ID","randomStringGenerator","module","createAsyncProviders","imports","input","moduleOptions","extrasKeys","keys","filter","includes","forEach","useExisting","useFactory","inject","provideInjectionTokensFrom","createAsyncOptionsProvider","getInjectionProviders","useClass","_ref","optionsFactory","_x","apply","arguments","typeName","proxy","Proxy","get","Error"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/common/module-utils/configurable-module.builder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurableModuleBuilder = void 0;\nconst logger_service_1 = require(\"../services/logger.service\");\nconst random_string_generator_util_1 = require(\"../utils/random-string-generator.util\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\n/**\n * Factory that lets you create configurable modules and\n * provides a way to reduce the majority of dynamic module boilerplate.\n *\n * @publicApi\n */\nclass ConfigurableModuleBuilder {\n    constructor(options = {}, parentBuilder) {\n        this.options = options;\n        this.logger = new logger_service_1.Logger(ConfigurableModuleBuilder.name);\n        if (parentBuilder) {\n            this.staticMethodKey = parentBuilder.staticMethodKey;\n            this.factoryClassMethodKey =\n                parentBuilder.factoryClassMethodKey;\n            this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\n            this.extras = parentBuilder.extras;\n        }\n    }\n    /**\n     * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\n     * Values you specify within the \"extras\" object will be used as default values (that can be overridden by module consumers).\n     *\n     * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\n     * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\n     * The \"extras\" object consists of values explicitly specified by module consumers and default values.\n     *\n     * @example\n     * ```typescript\n     * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\n     *    ({ ...definition, global: extras.isGlobal })\n     * )\n     * ```\n     */\n    setExtras(extras, transformDefinition = def => def) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.extras = extras;\n        builder.transformModuleDefinition = transformDefinition;\n        return builder;\n    }\n    /**\n     * Dynamic modules must expose public static methods that let you pass in\n     * configuration parameters (control the module's behavior from the outside).\n     * Some frequently used names that you may have seen in other modules are:\n     * \"forRoot\", \"forFeature\", \"register\", \"configure\".\n     *\n     * This method \"setClassMethodName\" lets you specify the name of the\n     * method that will be auto-generated.\n     *\n     * @param key name of the method\n     */\n    setClassMethodName(key) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.staticMethodKey = key;\n        return builder;\n    }\n    /**\n     * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\n     * let you pass the configuration factory class that will be registered and instantiated as a provider.\n     * This provider then will be used to retrieve the module's configuration. To provide the configuration,\n     * the corresponding factory method must be implemented.\n     *\n     * This method (\"setFactoryMethodName\") lets you control what method name will have to be\n     * implemented by the config factory (default is \"create\").\n     *\n     * @param key name of the method\n     */\n    setFactoryMethodName(key) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.factoryClassMethodKey = key;\n        return builder;\n    }\n    /**\n     * Returns an object consisting of multiple properties that lets you\n     * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\n     */\n    build() {\n        this.staticMethodKey ??= constants_1.DEFAULT_METHOD_KEY;\n        this.factoryClassMethodKey ??=\n            constants_1.DEFAULT_FACTORY_CLASS_METHOD_KEY;\n        this.options.optionsInjectionToken ??= this.options.moduleName\n            ? this.constructInjectionTokenString()\n            : (0, utils_1.generateOptionsInjectionToken)();\n        this.transformModuleDefinition ??= definition => definition;\n        return {\n            ConfigurableModuleClass: this.createConfigurableModuleCls(),\n            MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\n            ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\n            OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),\n        };\n    }\n    constructInjectionTokenString() {\n        const moduleNameInSnakeCase = this.options.moduleName\n            .trim()\n            .split(/(?=[A-Z])/)\n            .join('_')\n            .toUpperCase();\n        return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\n    }\n    createConfigurableModuleCls() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const asyncMethodKey = this.staticMethodKey + constants_1.ASYNC_METHOD_SUFFIX;\n        class InternalModuleClass {\n            static [self.staticMethodKey](options) {\n                const providers = [\n                    {\n                        provide: self.options.optionsInjectionToken,\n                        useValue: this.omitExtras(options, self.extras),\n                    },\n                ];\n                if (self.options.alwaysTransient) {\n                    providers.push({\n                        provide: constants_1.CONFIGURABLE_MODULE_ID,\n                        useValue: (0, random_string_generator_util_1.randomStringGenerator)(),\n                    });\n                }\n                return self.transformModuleDefinition({\n                    module: this,\n                    providers,\n                }, {\n                    ...self.extras,\n                    ...options,\n                });\n            }\n            static [asyncMethodKey](options) {\n                const providers = this.createAsyncProviders(options);\n                if (self.options.alwaysTransient) {\n                    providers.push({\n                        provide: constants_1.CONFIGURABLE_MODULE_ID,\n                        useValue: (0, random_string_generator_util_1.randomStringGenerator)(),\n                    });\n                }\n                return self.transformModuleDefinition({\n                    module: this,\n                    imports: options.imports || [],\n                    providers,\n                }, {\n                    ...self.extras,\n                    ...options,\n                });\n            }\n            static omitExtras(input, extras) {\n                if (!extras) {\n                    return input;\n                }\n                const moduleOptions = {};\n                const extrasKeys = Object.keys(extras);\n                Object.keys(input)\n                    .filter(key => !extrasKeys.includes(key))\n                    .forEach(key => {\n                    moduleOptions[key] = input[key];\n                });\n                return moduleOptions;\n            }\n            static createAsyncProviders(options) {\n                if (options.useExisting || options.useFactory) {\n                    if (options.inject && options.provideInjectionTokensFrom) {\n                        return [\n                            this.createAsyncOptionsProvider(options),\n                            ...(0, utils_1.getInjectionProviders)(options.provideInjectionTokensFrom, options.inject),\n                        ];\n                    }\n                    return [this.createAsyncOptionsProvider(options)];\n                }\n                return [\n                    this.createAsyncOptionsProvider(options),\n                    {\n                        provide: options.useClass,\n                        useClass: options.useClass,\n                    },\n                ];\n            }\n            static createAsyncOptionsProvider(options) {\n                if (options.useFactory) {\n                    return {\n                        provide: self.options.optionsInjectionToken,\n                        useFactory: options.useFactory,\n                        inject: options.inject || [],\n                    };\n                }\n                return {\n                    provide: self.options.optionsInjectionToken,\n                    useFactory: async (optionsFactory) => await optionsFactory[self.factoryClassMethodKey](),\n                    inject: [options.useExisting || options.useClass],\n                };\n            }\n        }\n        return InternalModuleClass;\n    }\n    createTypeProxy(typeName) {\n        const proxy = new Proxy({}, {\n            get: () => {\n                throw new Error(`\"${typeName}\" is not supposed to be used as a value.`);\n            },\n        });\n        return proxy;\n    }\n}\nexports.ConfigurableModuleBuilder = ConfigurableModuleBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
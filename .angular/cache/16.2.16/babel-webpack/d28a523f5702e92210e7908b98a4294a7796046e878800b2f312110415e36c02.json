{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Inject = Inject;\nconst constants_1 = require(\"../../constants\");\nconst shared_utils_1 = require(\"../../utils/shared.utils\");\n/**\n * Decorator that marks a constructor parameter as a target for\n * [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection).\n *\n * Any injected provider must be visible within the module scope (loosely\n * speaking, the containing module) of the class it is being injected into. This\n * can be done by:\n *\n * - defining the provider in the same module scope\n * - exporting the provider from one module scope and importing that module into the\n *   module scope of the class being injected into\n * - exporting the provider from a module that is marked as global using the\n *   `@Global()` decorator\n *\n * #### Injection tokens\n * Can be *types* (class names), *strings* or *symbols*. This depends on how the\n * provider with which it is associated was defined. Providers defined with the\n * `@Injectable()` decorator use the class name. Custom Providers may use strings\n * or symbols as the injection token.\n *\n * @param token lookup key for the provider to be injected (assigned to the constructor\n * parameter).\n *\n * @see [Providers](https://docs.nestjs.com/providers)\n * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)\n * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nfunction Inject(token) {\n  const injectCallHasArguments = arguments.length > 0;\n  return (target, key, index) => {\n    let type = token || Reflect.getMetadata('design:type', target, key);\n    // Try to infer the token in a constructor-based injection\n    if (!type && !injectCallHasArguments) {\n      type = Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, target, key)?.[index];\n    }\n    if (!(0, shared_utils_1.isUndefined)(index)) {\n      let dependencies = Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, target) || [];\n      dependencies = [...dependencies, {\n        index,\n        param: type\n      }];\n      Reflect.defineMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, dependencies, target);\n      return;\n    }\n    let properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, target.constructor) || [];\n    properties = [...properties, {\n      key,\n      type\n    }];\n    Reflect.defineMetadata(constants_1.PROPERTY_DEPS_METADATA, properties, target.constructor);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Inject","constants_1","require","shared_utils_1","token","injectCallHasArguments","arguments","length","target","key","index","type","Reflect","getMetadata","PARAMTYPES_METADATA","isUndefined","dependencies","SELF_DECLARED_DEPS_METADATA","param","defineMetadata","properties","PROPERTY_DEPS_METADATA","constructor"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/common/decorators/core/inject.decorator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Inject = Inject;\nconst constants_1 = require(\"../../constants\");\nconst shared_utils_1 = require(\"../../utils/shared.utils\");\n/**\n * Decorator that marks a constructor parameter as a target for\n * [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection).\n *\n * Any injected provider must be visible within the module scope (loosely\n * speaking, the containing module) of the class it is being injected into. This\n * can be done by:\n *\n * - defining the provider in the same module scope\n * - exporting the provider from one module scope and importing that module into the\n *   module scope of the class being injected into\n * - exporting the provider from a module that is marked as global using the\n *   `@Global()` decorator\n *\n * #### Injection tokens\n * Can be *types* (class names), *strings* or *symbols*. This depends on how the\n * provider with which it is associated was defined. Providers defined with the\n * `@Injectable()` decorator use the class name. Custom Providers may use strings\n * or symbols as the injection token.\n *\n * @param token lookup key for the provider to be injected (assigned to the constructor\n * parameter).\n *\n * @see [Providers](https://docs.nestjs.com/providers)\n * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)\n * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nfunction Inject(token) {\n    const injectCallHasArguments = arguments.length > 0;\n    return (target, key, index) => {\n        let type = token || Reflect.getMetadata('design:type', target, key);\n        // Try to infer the token in a constructor-based injection\n        if (!type && !injectCallHasArguments) {\n            type = Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, target, key)?.[index];\n        }\n        if (!(0, shared_utils_1.isUndefined)(index)) {\n            let dependencies = Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, target) || [];\n            dependencies = [...dependencies, { index, param: type }];\n            Reflect.defineMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, dependencies, target);\n            return;\n        }\n        let properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, target.constructor) || [];\n        properties = [...properties, { key, type }];\n        Reflect.defineMetadata(constants_1.PROPERTY_DEPS_METADATA, properties, target.constructor);\n    };\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,MAAM,GAAGA,MAAM;AACvB,MAAMC,WAAW,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAMC,cAAc,GAAGD,OAAO,CAAC,0BAA0B,CAAC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,MAAMA,CAACI,KAAK,EAAE;EACnB,MAAMC,sBAAsB,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC;EACnD,OAAO,CAACC,MAAM,EAAEC,GAAG,EAAEC,KAAK,KAAK;IAC3B,IAAIC,IAAI,GAAGP,KAAK,IAAIQ,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEL,MAAM,EAAEC,GAAG,CAAC;IACnE;IACA,IAAI,CAACE,IAAI,IAAI,CAACN,sBAAsB,EAAE;MAClCM,IAAI,GAAGC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,mBAAmB,EAAEN,MAAM,EAAEC,GAAG,CAAC,GAAGC,KAAK,CAAC;IACrF;IACA,IAAI,CAAC,CAAC,CAAC,EAAEP,cAAc,CAACY,WAAW,EAAEL,KAAK,CAAC,EAAE;MACzC,IAAIM,YAAY,GAAGJ,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACgB,2BAA2B,EAAET,MAAM,CAAC,IAAI,EAAE;MAC7FQ,YAAY,GAAG,CAAC,GAAGA,YAAY,EAAE;QAAEN,KAAK;QAAEQ,KAAK,EAAEP;MAAK,CAAC,CAAC;MACxDC,OAAO,CAACO,cAAc,CAAClB,WAAW,CAACgB,2BAA2B,EAAED,YAAY,EAAER,MAAM,CAAC;MACrF;IACJ;IACA,IAAIY,UAAU,GAAGR,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACoB,sBAAsB,EAAEb,MAAM,CAACc,WAAW,CAAC,IAAI,EAAE;IAClGF,UAAU,GAAG,CAAC,GAAGA,UAAU,EAAE;MAAEX,GAAG;MAAEE;IAAK,CAAC,CAAC;IAC3CC,OAAO,CAACO,cAAc,CAAClB,WAAW,CAACoB,sBAAsB,EAAED,UAAU,EAAEZ,MAAM,CAACc,WAAW,CAAC;EAC9F,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
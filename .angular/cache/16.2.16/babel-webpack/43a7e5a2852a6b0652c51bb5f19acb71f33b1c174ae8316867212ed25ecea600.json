{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LazyModuleLoader = void 0;\nconst silent_logger_1 = require(\"../helpers/silent-logger\");\nconst module_ref_1 = require(\"../module-ref\");\nclass LazyModuleLoader {\n  constructor(dependenciesScanner, instanceLoader, moduleCompiler, modulesContainer, moduleOverrides) {\n    this.dependenciesScanner = dependenciesScanner;\n    this.instanceLoader = instanceLoader;\n    this.moduleCompiler = moduleCompiler;\n    this.modulesContainer = modulesContainer;\n    this.moduleOverrides = moduleOverrides;\n  }\n  load(loaderFn, loadOpts) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.registerLoggerConfiguration(loadOpts);\n      const moduleClassOrDynamicDefinition = yield loaderFn();\n      const moduleInstances = yield _this.dependenciesScanner.scanForModules({\n        moduleDefinition: moduleClassOrDynamicDefinition,\n        overrides: _this.moduleOverrides,\n        lazy: true\n      });\n      if (moduleInstances.length === 0) {\n        // The module has been loaded already. In this case, we must\n        // retrieve a module reference from the existing container.\n        const {\n          token\n        } = yield _this.moduleCompiler.compile(moduleClassOrDynamicDefinition);\n        const moduleInstance = _this.modulesContainer.get(token);\n        return moduleInstance && _this.getTargetModuleRef(moduleInstance);\n      }\n      const lazyModulesContainer = _this.createLazyModulesContainer(moduleInstances);\n      yield _this.dependenciesScanner.scanModulesForDependencies(lazyModulesContainer);\n      yield _this.instanceLoader.createInstancesOfDependencies(lazyModulesContainer);\n      const [targetModule] = moduleInstances;\n      return _this.getTargetModuleRef(targetModule);\n    })();\n  }\n  registerLoggerConfiguration(loadOpts) {\n    if (loadOpts?.logger === false) {\n      this.instanceLoader.setLogger(new silent_logger_1.SilentLogger());\n    }\n  }\n  createLazyModulesContainer(moduleInstances) {\n    moduleInstances = Array.from(new Set(moduleInstances));\n    return new Map(moduleInstances.map(ref => [ref.token, ref]));\n  }\n  getTargetModuleRef(moduleInstance) {\n    const moduleRefInstanceWrapper = moduleInstance.getProviderByKey(module_ref_1.ModuleRef);\n    return moduleRefInstanceWrapper.instance;\n  }\n}\nexports.LazyModuleLoader = LazyModuleLoader;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","LazyModuleLoader","silent_logger_1","module_ref_1","constructor","dependenciesScanner","instanceLoader","moduleCompiler","modulesContainer","moduleOverrides","load","loaderFn","loadOpts","_this","registerLoggerConfiguration","moduleClassOrDynamicDefinition","moduleInstances","scanForModules","moduleDefinition","overrides","lazy","length","token","compile","moduleInstance","get","getTargetModuleRef","lazyModulesContainer","createLazyModulesContainer","scanModulesForDependencies","createInstancesOfDependencies","targetModule","logger","setLogger","SilentLogger","Array","from","Set","Map","map","ref","moduleRefInstanceWrapper","getProviderByKey","ModuleRef","instance"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/core/injector/lazy-module-loader/lazy-module-loader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LazyModuleLoader = void 0;\nconst silent_logger_1 = require(\"../helpers/silent-logger\");\nconst module_ref_1 = require(\"../module-ref\");\nclass LazyModuleLoader {\n    constructor(dependenciesScanner, instanceLoader, moduleCompiler, modulesContainer, moduleOverrides) {\n        this.dependenciesScanner = dependenciesScanner;\n        this.instanceLoader = instanceLoader;\n        this.moduleCompiler = moduleCompiler;\n        this.modulesContainer = modulesContainer;\n        this.moduleOverrides = moduleOverrides;\n    }\n    async load(loaderFn, loadOpts) {\n        this.registerLoggerConfiguration(loadOpts);\n        const moduleClassOrDynamicDefinition = await loaderFn();\n        const moduleInstances = await this.dependenciesScanner.scanForModules({\n            moduleDefinition: moduleClassOrDynamicDefinition,\n            overrides: this.moduleOverrides,\n            lazy: true,\n        });\n        if (moduleInstances.length === 0) {\n            // The module has been loaded already. In this case, we must\n            // retrieve a module reference from the existing container.\n            const { token } = await this.moduleCompiler.compile(moduleClassOrDynamicDefinition);\n            const moduleInstance = this.modulesContainer.get(token);\n            return moduleInstance && this.getTargetModuleRef(moduleInstance);\n        }\n        const lazyModulesContainer = this.createLazyModulesContainer(moduleInstances);\n        await this.dependenciesScanner.scanModulesForDependencies(lazyModulesContainer);\n        await this.instanceLoader.createInstancesOfDependencies(lazyModulesContainer);\n        const [targetModule] = moduleInstances;\n        return this.getTargetModuleRef(targetModule);\n    }\n    registerLoggerConfiguration(loadOpts) {\n        if (loadOpts?.logger === false) {\n            this.instanceLoader.setLogger(new silent_logger_1.SilentLogger());\n        }\n    }\n    createLazyModulesContainer(moduleInstances) {\n        moduleInstances = Array.from(new Set(moduleInstances));\n        return new Map(moduleInstances.map(ref => [ref.token, ref]));\n    }\n    getTargetModuleRef(moduleInstance) {\n        const moduleRefInstanceWrapper = moduleInstance.getProviderByKey(module_ref_1.ModuleRef);\n        return moduleRefInstanceWrapper.instance;\n    }\n}\nexports.LazyModuleLoader = LazyModuleLoader;\n"],"mappings":"AAAA,YAAY;;AAAC,IAAAA,iBAAA,GAAAC,OAAA,wHAAAC,OAAA;AACbC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,gBAAgB,GAAG,KAAK,CAAC;AACjC,MAAMC,eAAe,GAAGP,OAAO,CAAC,0BAA0B,CAAC;AAC3D,MAAMQ,YAAY,GAAGR,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAMM,gBAAgB,CAAC;EACnBG,WAAWA,CAACC,mBAAmB,EAAEC,cAAc,EAAEC,cAAc,EAAEC,gBAAgB,EAAEC,eAAe,EAAE;IAChG,IAAI,CAACJ,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,eAAe,GAAGA,eAAe;EAC1C;EACMC,IAAIA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;IAAA,IAAAC,KAAA;IAAA,OAAAnB,iBAAA;MAC3BmB,KAAI,CAACC,2BAA2B,CAACF,QAAQ,CAAC;MAC1C,MAAMG,8BAA8B,SAASJ,QAAQ,CAAC,CAAC;MACvD,MAAMK,eAAe,SAASH,KAAI,CAACR,mBAAmB,CAACY,cAAc,CAAC;QAClEC,gBAAgB,EAAEH,8BAA8B;QAChDI,SAAS,EAAEN,KAAI,CAACJ,eAAe;QAC/BW,IAAI,EAAE;MACV,CAAC,CAAC;MACF,IAAIJ,eAAe,CAACK,MAAM,KAAK,CAAC,EAAE;QAC9B;QACA;QACA,MAAM;UAAEC;QAAM,CAAC,SAAST,KAAI,CAACN,cAAc,CAACgB,OAAO,CAACR,8BAA8B,CAAC;QACnF,MAAMS,cAAc,GAAGX,KAAI,CAACL,gBAAgB,CAACiB,GAAG,CAACH,KAAK,CAAC;QACvD,OAAOE,cAAc,IAAIX,KAAI,CAACa,kBAAkB,CAACF,cAAc,CAAC;MACpE;MACA,MAAMG,oBAAoB,GAAGd,KAAI,CAACe,0BAA0B,CAACZ,eAAe,CAAC;MAC7E,MAAMH,KAAI,CAACR,mBAAmB,CAACwB,0BAA0B,CAACF,oBAAoB,CAAC;MAC/E,MAAMd,KAAI,CAACP,cAAc,CAACwB,6BAA6B,CAACH,oBAAoB,CAAC;MAC7E,MAAM,CAACI,YAAY,CAAC,GAAGf,eAAe;MACtC,OAAOH,KAAI,CAACa,kBAAkB,CAACK,YAAY,CAAC;IAAC;EACjD;EACAjB,2BAA2BA,CAACF,QAAQ,EAAE;IAClC,IAAIA,QAAQ,EAAEoB,MAAM,KAAK,KAAK,EAAE;MAC5B,IAAI,CAAC1B,cAAc,CAAC2B,SAAS,CAAC,IAAI/B,eAAe,CAACgC,YAAY,CAAC,CAAC,CAAC;IACrE;EACJ;EACAN,0BAA0BA,CAACZ,eAAe,EAAE;IACxCA,eAAe,GAAGmB,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAACrB,eAAe,CAAC,CAAC;IACtD,OAAO,IAAIsB,GAAG,CAACtB,eAAe,CAACuB,GAAG,CAACC,GAAG,IAAI,CAACA,GAAG,CAAClB,KAAK,EAAEkB,GAAG,CAAC,CAAC,CAAC;EAChE;EACAd,kBAAkBA,CAACF,cAAc,EAAE;IAC/B,MAAMiB,wBAAwB,GAAGjB,cAAc,CAACkB,gBAAgB,CAACvC,YAAY,CAACwC,SAAS,CAAC;IACxF,OAAOF,wBAAwB,CAACG,QAAQ;EAC5C;AACJ;AACA7C,OAAO,CAACE,gBAAgB,GAAGA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
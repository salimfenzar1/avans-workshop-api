{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DiscoverableMetaHostCollection = void 0;\nclass DiscoverableMetaHostCollection {\n  /**\n   * Adds a link between a class reference and a metadata key.\n   * @param target The class reference.\n   * @param metadataKey The metadata key.\n   */\n  static addClassMetaHostLink(target, metadataKey) {\n    this.metaHostLinks.set(target, metadataKey);\n  }\n  /**\n   * Inspects a provider instance wrapper and adds it to the collection of providers\n   * if it has a metadata key.\n   * @param hostContainerRef A reference to the modules container.\n   * @param instanceWrapper A provider instance wrapper.\n   * @returns void\n   */\n  static inspectProvider(hostContainerRef, instanceWrapper) {\n    return this.inspectInstanceWrapper(hostContainerRef, instanceWrapper, this.providersByMetaKey);\n  }\n  /**\n   * Inspects a controller instance wrapper and adds it to the collection of controllers\n   * if it has a metadata key.\n   * @param hostContainerRef A reference to the modules container.\n   * @param instanceWrapper A controller's instance wrapper.\n   * @returns void\n   */\n  static inspectController(hostContainerRef, instanceWrapper) {\n    return this.inspectInstanceWrapper(hostContainerRef, instanceWrapper, this.controllersByMetaKey);\n  }\n  static insertByMetaKey(metaKey, instanceWrapper, collection) {\n    if (collection.has(metaKey)) {\n      const wrappers = collection.get(metaKey);\n      wrappers.add(instanceWrapper);\n    } else {\n      const wrappers = new Set();\n      wrappers.add(instanceWrapper);\n      collection.set(metaKey, wrappers);\n    }\n  }\n  static getProvidersByMetaKey(hostContainerRef, metaKey) {\n    const wrappersByMetaKey = this.providersByMetaKey.get(hostContainerRef);\n    return wrappersByMetaKey?.get(metaKey) ?? new Set();\n  }\n  static getControllersByMetaKey(hostContainerRef, metaKey) {\n    const wrappersByMetaKey = this.controllersByMetaKey.get(hostContainerRef);\n    return wrappersByMetaKey?.get(metaKey) ?? new Set();\n  }\n  static inspectInstanceWrapper(hostContainerRef, instanceWrapper, wrapperByMetaKeyMap) {\n    const metaKey = DiscoverableMetaHostCollection.getMetaKeyByInstanceWrapper(instanceWrapper);\n    if (!metaKey) {\n      return;\n    }\n    let collection;\n    if (wrapperByMetaKeyMap.has(hostContainerRef)) {\n      collection = wrapperByMetaKeyMap.get(hostContainerRef);\n    } else {\n      collection = new Map();\n      wrapperByMetaKeyMap.set(hostContainerRef, collection);\n    }\n    this.insertByMetaKey(metaKey, instanceWrapper, collection);\n  }\n  static getMetaKeyByInstanceWrapper(instanceWrapper) {\n    return this.metaHostLinks.get(\n    // NOTE: Regarding the ternary statement below,\n    // - The condition `!wrapper.metatype` is needed because when we use `useValue`\n    // the value of `wrapper.metatype` will be `null`.\n    // - The condition `wrapper.inject` is needed here because when we use\n    // `useFactory`, the value of `wrapper.metatype` will be the supplied\n    // factory function.\n    // For both cases, we should use `wrapper.instance.constructor` instead\n    // of `wrapper.metatype` to resolve processor's class properly.\n    // But since calling `wrapper.instance` could degrade overall performance\n    // we must defer it as much we can.\n    instanceWrapper.metatype || instanceWrapper.inject ? instanceWrapper.instance?.constructor ?? instanceWrapper.metatype : instanceWrapper.metatype);\n  }\n}\nexports.DiscoverableMetaHostCollection = DiscoverableMetaHostCollection;\n/**\n * A map of class references to metadata keys.\n */\nDiscoverableMetaHostCollection.metaHostLinks = new Map();\n/**\n * A map of metadata keys to instance wrappers (providers) with the corresponding metadata key.\n * The map is weakly referenced by the modules container (unique per application).\n */\nDiscoverableMetaHostCollection.providersByMetaKey = new WeakMap();\n/**\n * A map of metadata keys to instance wrappers (controllers) with the corresponding metadata key.\n * The map is weakly referenced by the modules container (unique per application).\n */\nDiscoverableMetaHostCollection.controllersByMetaKey = new WeakMap();","map":{"version":3,"names":["Object","defineProperty","exports","value","DiscoverableMetaHostCollection","addClassMetaHostLink","target","metadataKey","metaHostLinks","set","inspectProvider","hostContainerRef","instanceWrapper","inspectInstanceWrapper","providersByMetaKey","inspectController","controllersByMetaKey","insertByMetaKey","metaKey","collection","has","wrappers","get","add","Set","getProvidersByMetaKey","wrappersByMetaKey","getControllersByMetaKey","wrapperByMetaKeyMap","getMetaKeyByInstanceWrapper","Map","metatype","inject","instance","constructor","WeakMap"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/core/discovery/discoverable-meta-host-collection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscoverableMetaHostCollection = void 0;\nclass DiscoverableMetaHostCollection {\n    /**\n     * Adds a link between a class reference and a metadata key.\n     * @param target The class reference.\n     * @param metadataKey The metadata key.\n     */\n    static addClassMetaHostLink(target, metadataKey) {\n        this.metaHostLinks.set(target, metadataKey);\n    }\n    /**\n     * Inspects a provider instance wrapper and adds it to the collection of providers\n     * if it has a metadata key.\n     * @param hostContainerRef A reference to the modules container.\n     * @param instanceWrapper A provider instance wrapper.\n     * @returns void\n     */\n    static inspectProvider(hostContainerRef, instanceWrapper) {\n        return this.inspectInstanceWrapper(hostContainerRef, instanceWrapper, this.providersByMetaKey);\n    }\n    /**\n     * Inspects a controller instance wrapper and adds it to the collection of controllers\n     * if it has a metadata key.\n     * @param hostContainerRef A reference to the modules container.\n     * @param instanceWrapper A controller's instance wrapper.\n     * @returns void\n     */\n    static inspectController(hostContainerRef, instanceWrapper) {\n        return this.inspectInstanceWrapper(hostContainerRef, instanceWrapper, this.controllersByMetaKey);\n    }\n    static insertByMetaKey(metaKey, instanceWrapper, collection) {\n        if (collection.has(metaKey)) {\n            const wrappers = collection.get(metaKey);\n            wrappers.add(instanceWrapper);\n        }\n        else {\n            const wrappers = new Set();\n            wrappers.add(instanceWrapper);\n            collection.set(metaKey, wrappers);\n        }\n    }\n    static getProvidersByMetaKey(hostContainerRef, metaKey) {\n        const wrappersByMetaKey = this.providersByMetaKey.get(hostContainerRef);\n        return wrappersByMetaKey?.get(metaKey) ?? new Set();\n    }\n    static getControllersByMetaKey(hostContainerRef, metaKey) {\n        const wrappersByMetaKey = this.controllersByMetaKey.get(hostContainerRef);\n        return wrappersByMetaKey?.get(metaKey) ?? new Set();\n    }\n    static inspectInstanceWrapper(hostContainerRef, instanceWrapper, wrapperByMetaKeyMap) {\n        const metaKey = DiscoverableMetaHostCollection.getMetaKeyByInstanceWrapper(instanceWrapper);\n        if (!metaKey) {\n            return;\n        }\n        let collection;\n        if (wrapperByMetaKeyMap.has(hostContainerRef)) {\n            collection = wrapperByMetaKeyMap.get(hostContainerRef);\n        }\n        else {\n            collection = new Map();\n            wrapperByMetaKeyMap.set(hostContainerRef, collection);\n        }\n        this.insertByMetaKey(metaKey, instanceWrapper, collection);\n    }\n    static getMetaKeyByInstanceWrapper(instanceWrapper) {\n        return this.metaHostLinks.get(\n        // NOTE: Regarding the ternary statement below,\n        // - The condition `!wrapper.metatype` is needed because when we use `useValue`\n        // the value of `wrapper.metatype` will be `null`.\n        // - The condition `wrapper.inject` is needed here because when we use\n        // `useFactory`, the value of `wrapper.metatype` will be the supplied\n        // factory function.\n        // For both cases, we should use `wrapper.instance.constructor` instead\n        // of `wrapper.metatype` to resolve processor's class properly.\n        // But since calling `wrapper.instance` could degrade overall performance\n        // we must defer it as much we can.\n        instanceWrapper.metatype || instanceWrapper.inject\n            ? (instanceWrapper.instance?.constructor ?? instanceWrapper.metatype)\n            : instanceWrapper.metatype);\n    }\n}\nexports.DiscoverableMetaHostCollection = DiscoverableMetaHostCollection;\n/**\n * A map of class references to metadata keys.\n */\nDiscoverableMetaHostCollection.metaHostLinks = new Map();\n/**\n * A map of metadata keys to instance wrappers (providers) with the corresponding metadata key.\n * The map is weakly referenced by the modules container (unique per application).\n */\nDiscoverableMetaHostCollection.providersByMetaKey = new WeakMap();\n/**\n * A map of metadata keys to instance wrappers (controllers) with the corresponding metadata key.\n * The map is weakly referenced by the modules container (unique per application).\n */\nDiscoverableMetaHostCollection.controllersByMetaKey = new WeakMap();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options) {\n  let constraintCls;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint {\n      validate(value, validationArguments) {\n        return validator.validate(value, validationArguments);\n      }\n      defaultMessage(validationArguments) {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n  const validationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    name: options.name,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}","map":{"version":3,"names":["ConstraintMetadata","ValidationMetadata","ValidationTypes","getFromContainer","MetadataStorage","getMetadataStorage","registerDecorator","options","constraintCls","validator","Function","constraintClasses","getTargetValidatorConstraints","length","target","name","propertyName","CustomConstraint","validate","value","validationArguments","defaultMessage","addConstraintMetadata","async","validationMetadataArgs","type","isValid","CUSTOM_VALIDATION","validationOptions","constraints","addValidationMetadata"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/class-validator/esm2015/register-decorator.js"],"sourcesContent":["import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options) {\n    let constraintCls;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n        }\n    }\n    else {\n        const validator = options.validator;\n        constraintCls = class CustomConstraint {\n            validate(value, validationArguments) {\n                return validator.validate(value, validationArguments);\n            }\n            defaultMessage(validationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n                return '';\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n    const validationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        name: options.name,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints,\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,+BAA+B;AAClE,SAASC,kBAAkB,QAAQ,+BAA+B;AAClE,SAASC,eAAe,QAAQ,8BAA8B;AAC9D,SAASC,gBAAgB,QAAQ,aAAa;AAC9C,SAASC,eAAe,EAAEC,kBAAkB,QAAQ,4BAA4B;AAChF;AACA;AACA;AACA,OAAO,SAASC,iBAAiBA,CAACC,OAAO,EAAE;EACvC,IAAIC,aAAa;EACjB,IAAID,OAAO,CAACE,SAAS,YAAYC,QAAQ,EAAE;IACvCF,aAAa,GAAGD,OAAO,CAACE,SAAS;IACjC,MAAME,iBAAiB,GAAGR,gBAAgB,CAACC,eAAe,CAAC,CAACQ,6BAA6B,CAACL,OAAO,CAACE,SAAS,CAAC;IAC5G,IAAIE,iBAAiB,CAACE,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAO,wFAAuFN,OAAO,CAACO,MAAM,CAACC,IAAK,IAAGR,OAAO,CAACS,YAAa,EAAC;IAC/I;EACJ,CAAC,MACI;IACD,MAAMP,SAAS,GAAGF,OAAO,CAACE,SAAS;IACnCD,aAAa,GAAG,MAAMS,gBAAgB,CAAC;MACnCC,QAAQA,CAACC,KAAK,EAAEC,mBAAmB,EAAE;QACjC,OAAOX,SAAS,CAACS,QAAQ,CAACC,KAAK,EAAEC,mBAAmB,CAAC;MACzD;MACAC,cAAcA,CAACD,mBAAmB,EAAE;QAChC,IAAIX,SAAS,CAACY,cAAc,EAAE;UAC1B,OAAOZ,SAAS,CAACY,cAAc,CAACD,mBAAmB,CAAC;QACxD;QACA,OAAO,EAAE;MACb;IACJ,CAAC;IACDf,kBAAkB,CAAC,CAAC,CAACiB,qBAAqB,CAAC,IAAItB,kBAAkB,CAACQ,aAAa,EAAED,OAAO,CAACQ,IAAI,EAAER,OAAO,CAACgB,KAAK,CAAC,CAAC;EAClH;EACA,MAAMC,sBAAsB,GAAG;IAC3BC,IAAI,EAAElB,OAAO,CAACQ,IAAI,IAAIb,eAAe,CAACwB,OAAO,CAACnB,OAAO,CAACQ,IAAI,CAAC,GAAGR,OAAO,CAACQ,IAAI,GAAGb,eAAe,CAACyB,iBAAiB;IAC9GZ,IAAI,EAAER,OAAO,CAACQ,IAAI;IAClBD,MAAM,EAAEP,OAAO,CAACO,MAAM;IACtBE,YAAY,EAAET,OAAO,CAACS,YAAY;IAClCY,iBAAiB,EAAErB,OAAO,CAACA,OAAO;IAClCC,aAAa,EAAEA,aAAa;IAC5BqB,WAAW,EAAEtB,OAAO,CAACsB;EACzB,CAAC;EACDxB,kBAAkB,CAAC,CAAC,CAACyB,qBAAqB,CAAC,IAAI7B,kBAAkB,CAACuB,sBAAsB,CAAC,CAAC;AAC9F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n      var _this$context$ = this.context[0],\n        branches = _this$context$.branches,\n        instructions = _this$context$.instructions;\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n      /* istanbul ignore if */\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n      var match = pattern.match(OPERATOR);\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n          if (before) {\n            this.parsePattern(before);\n          }\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n          var _this$getContext = this.getContext(),\n            branches = _this$getContext.branches;\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n  return PatternParser;\n}();\nexport { PatternParser as default };\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n    i++;\n  }\n  return values;\n}\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp(\n// any of:\n'(' +\n// or operator\n'\\\\|' +\n// or\n'|' +\n// or group start\n'\\\\(\\\\?\\\\:' +\n// or\n'|' +\n// or group end\n'\\\\)' +\n// or\n'|' +\n// one-of set start\n'\\\\[' +\n// or\n'|' +\n// one-of set end\n'\\\\]' + ')');\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n  return array;\n}","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","PatternParser","value","parse","pattern","context","or","instructions","parsePattern","Error","_this$context$","branches","op","args","concat","expandSingleElementArray","startContext","push","endContext","pop","getContext","match","OPERATOR","ILLEGAL_CHARACTER_REGEXP","test","split","operator","before","slice","index","rightPart","_this$getContext","oneOfSet","parseOneOfSet","default","values","prevValue","charCodeAt","nextValue","String","fromCharCode","RegExp","array"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n\n      var _this$context$ = this.context[0],\n          branches = _this$context$.branches,\n          instructions = _this$context$.instructions;\n\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n      /* istanbul ignore if */\n\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n\n      var match = pattern.match(OPERATOR);\n\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n\n          var _this$getContext = this.getContext(),\n              branches = _this$getContext.branches;\n\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n\n  return PatternParser;\n}();\n\nexport { PatternParser as default };\n\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n\n    i++;\n  }\n\n  return values;\n}\n\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp( // any of:\n'(' + // or operator\n'\\\\|' + // or\n'|' + // or group start\n'\\\\(\\\\?\\\\:' + // or\n'|' + // or group end\n'\\\\)' + // or\n'|' + // one-of set start\n'\\\\[' + // or\n'|' + // one-of set end\n'\\\\]' + ')');\n\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n\n  return array;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
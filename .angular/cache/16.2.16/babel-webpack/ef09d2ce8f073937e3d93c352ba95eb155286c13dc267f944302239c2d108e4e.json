{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Injectable = Injectable;\nexports.mixin = mixin;\nconst uid_1 = require(\"uid\");\nconst constants_1 = require(\"../../constants\");\n/**\n * Decorator that marks a class as a [provider](https://docs.nestjs.com/providers).\n * Providers can be injected into other classes via constructor parameter injection\n * using Nest's built-in [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection)\n * system.\n *\n * When injecting a provider, it must be visible within the module scope (loosely\n * speaking, the containing module) of the class it is being injected into. This\n * can be done by:\n *\n * - defining the provider in the same module scope\n * - exporting the provider from one module scope and importing that module into the\n *   module scope of the class being injected into\n * - exporting the provider from a module that is marked as global using the\n *   `@Global()` decorator\n *\n * Providers can also be defined in a more explicit and imperative form using\n * various [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) techniques that expose\n * more capabilities of the DI system.\n *\n * @param options options specifying scope of injectable\n *\n * @see [Providers](https://docs.nestjs.com/providers)\n * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)\n * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nfunction Injectable(options) {\n  return target => {\n    Reflect.defineMetadata(constants_1.INJECTABLE_WATERMARK, true, target);\n    Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, options, target);\n  };\n}\n/**\n * @publicApi\n */\nfunction mixin(mixinClass) {\n  Object.defineProperty(mixinClass, 'name', {\n    value: (0, uid_1.uid)(21)\n  });\n  Injectable()(mixinClass);\n  return mixinClass;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Injectable","mixin","uid_1","require","constants_1","options","target","Reflect","defineMetadata","INJECTABLE_WATERMARK","SCOPE_OPTIONS_METADATA","mixinClass","uid"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/common/decorators/core/injectable.decorator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Injectable = Injectable;\nexports.mixin = mixin;\nconst uid_1 = require(\"uid\");\nconst constants_1 = require(\"../../constants\");\n/**\n * Decorator that marks a class as a [provider](https://docs.nestjs.com/providers).\n * Providers can be injected into other classes via constructor parameter injection\n * using Nest's built-in [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection)\n * system.\n *\n * When injecting a provider, it must be visible within the module scope (loosely\n * speaking, the containing module) of the class it is being injected into. This\n * can be done by:\n *\n * - defining the provider in the same module scope\n * - exporting the provider from one module scope and importing that module into the\n *   module scope of the class being injected into\n * - exporting the provider from a module that is marked as global using the\n *   `@Global()` decorator\n *\n * Providers can also be defined in a more explicit and imperative form using\n * various [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) techniques that expose\n * more capabilities of the DI system.\n *\n * @param options options specifying scope of injectable\n *\n * @see [Providers](https://docs.nestjs.com/providers)\n * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)\n * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nfunction Injectable(options) {\n    return (target) => {\n        Reflect.defineMetadata(constants_1.INJECTABLE_WATERMARK, true, target);\n        Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, options, target);\n    };\n}\n/**\n * @publicApi\n */\nfunction mixin(mixinClass) {\n    Object.defineProperty(mixinClass, 'name', {\n        value: (0, uid_1.uid)(21),\n    });\n    Injectable()(mixinClass);\n    return mixinClass;\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAGA,UAAU;AAC/BF,OAAO,CAACG,KAAK,GAAGA,KAAK;AACrB,MAAMC,KAAK,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMC,WAAW,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASH,UAAUA,CAACK,OAAO,EAAE;EACzB,OAAQC,MAAM,IAAK;IACfC,OAAO,CAACC,cAAc,CAACJ,WAAW,CAACK,oBAAoB,EAAE,IAAI,EAAEH,MAAM,CAAC;IACtEC,OAAO,CAACC,cAAc,CAACJ,WAAW,CAACM,sBAAsB,EAAEL,OAAO,EAAEC,MAAM,CAAC;EAC/E,CAAC;AACL;AACA;AACA;AACA;AACA,SAASL,KAAKA,CAACU,UAAU,EAAE;EACvBf,MAAM,CAACC,cAAc,CAACc,UAAU,EAAE,MAAM,EAAE;IACtCZ,KAAK,EAAE,CAAC,CAAC,EAAEG,KAAK,CAACU,GAAG,EAAE,EAAE;EAC5B,CAAC,CAAC;EACFZ,UAAU,CAAC,CAAC,CAACW,UAAU,CAAC;EACxB,OAAOA,UAAU;AACrB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
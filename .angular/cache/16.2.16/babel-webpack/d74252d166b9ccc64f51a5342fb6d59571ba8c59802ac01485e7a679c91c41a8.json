{"ast":null,"code":"import { TransformationType } from './enums';\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this._typeMetadatas = new Map();\n    this._transformMetadatas = new Map();\n    this._exposeMetadatas = new Map();\n    this._excludeMetadatas = new Map();\n    this._ancestorsMap = new Map();\n  }\n  // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n  addTypeMetadata(metadata) {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map());\n    }\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  addTransformMetadata(metadata) {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map());\n    }\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  }\n  addExposeMetadata(metadata) {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map());\n    }\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  addExcludeMetadata(metadata) {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map());\n    }\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  findTransformMetadatas(target, propertyName, transformationType) {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    });\n  }\n  findExcludeMetadata(target, propertyName) {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  }\n  findExposeMetadata(target, propertyName) {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  }\n  findExposeMetadataByCustomName(target, name) {\n    return this.getExposedMetadatas(target).find(metadata => {\n      return metadata.options && metadata.options.name === name;\n    });\n  }\n  findTypeMetadata(target, propertyName) {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  }\n  getStrategy(target) {\n    const excludeMap = this._excludeMetadatas.get(target);\n    const exclude = excludeMap && excludeMap.get(undefined);\n    const exposeMap = this._exposeMetadatas.get(target);\n    const expose = exposeMap && exposeMap.get(undefined);\n    if (exclude && expose || !exclude && !expose) return 'none';\n    return exclude ? 'excludeAll' : 'exposeAll';\n  }\n  getExposedMetadatas(target) {\n    return this.getMetadata(this._exposeMetadatas, target);\n  }\n  getExcludedMetadatas(target) {\n    return this.getMetadata(this._excludeMetadatas, target);\n  }\n  getExposedProperties(target, transformationType) {\n    return this.getExposedMetadatas(target).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    }).map(metadata => metadata.propertyName);\n  }\n  getExcludedProperties(target, transformationType) {\n    return this.getExcludedMetadatas(target).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    }).map(metadata => metadata.propertyName);\n  }\n  clear() {\n    this._typeMetadatas.clear();\n    this._exposeMetadatas.clear();\n    this._excludeMetadatas.clear();\n    this._ancestorsMap.clear();\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  getMetadata(metadatas, target) {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget;\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n    }\n    const metadataFromAncestors = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n        metadataFromAncestors.push(...metadataFromAncestor);\n      }\n    }\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  }\n  findMetadata(metadatas, target, propertyName) {\n    const metadataFromTargetMap = metadatas.get(target);\n    if (metadataFromTargetMap) {\n      const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const ancestorResult = ancestorMetadataMap.get(propertyName);\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n    return undefined;\n  }\n  findMetadatas(metadatas, target, propertyName) {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget;\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n    const metadataFromAncestorsTarget = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n    return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());\n  }\n  getAncestors(target) {\n    if (!target) return [];\n    if (!this._ancestorsMap.has(target)) {\n      const ancestors = [];\n      for (let baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n        ancestors.push(baseClass);\n      }\n      this._ancestorsMap.set(target, ancestors);\n    }\n    return this._ancestorsMap.get(target);\n  }\n}","map":{"version":3,"names":["TransformationType","MetadataStorage","constructor","_typeMetadatas","Map","_transformMetadatas","_exposeMetadatas","_excludeMetadatas","_ancestorsMap","addTypeMetadata","metadata","has","target","set","get","propertyName","addTransformMetadata","push","addExposeMetadata","addExcludeMetadata","findTransformMetadatas","transformationType","findMetadatas","filter","options","toClassOnly","toPlainOnly","CLASS_TO_CLASS","PLAIN_TO_CLASS","CLASS_TO_PLAIN","findExcludeMetadata","findMetadata","findExposeMetadata","findExposeMetadataByCustomName","name","getExposedMetadatas","find","findTypeMetadata","getStrategy","excludeMap","exclude","undefined","exposeMap","expose","getMetadata","getExcludedMetadatas","getExposedProperties","map","getExcludedProperties","clear","metadatas","metadataFromTargetMap","metadataFromTarget","Array","from","values","meta","metadataFromAncestors","ancestor","getAncestors","ancestorMetadataMap","metadataFromAncestor","concat","ancestorResult","metadataFromAncestorsTarget","slice","reverse","ancestors","baseClass","Object","getPrototypeOf","prototype"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/class-transformer/esm2015/MetadataStorage.js"],"sourcesContent":["import { TransformationType } from './enums';\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n    constructor() {\n        // -------------------------------------------------------------------------\n        // Properties\n        // -------------------------------------------------------------------------\n        this._typeMetadatas = new Map();\n        this._transformMetadatas = new Map();\n        this._exposeMetadatas = new Map();\n        this._excludeMetadatas = new Map();\n        this._ancestorsMap = new Map();\n    }\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n    addTypeMetadata(metadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map());\n        }\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n    addTransformMetadata(metadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map());\n        }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n        }\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n    }\n    addExposeMetadata(metadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map());\n        }\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n    addExcludeMetadata(metadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map());\n        }\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    findTransformMetadatas(target, propertyName, transformationType) {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        });\n    }\n    findExcludeMetadata(target, propertyName) {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    }\n    findExposeMetadata(target, propertyName) {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    }\n    findExposeMetadataByCustomName(target, name) {\n        return this.getExposedMetadatas(target).find(metadata => {\n            return metadata.options && metadata.options.name === name;\n        });\n    }\n    findTypeMetadata(target, propertyName) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    }\n    getStrategy(target) {\n        const excludeMap = this._excludeMetadatas.get(target);\n        const exclude = excludeMap && excludeMap.get(undefined);\n        const exposeMap = this._exposeMetadatas.get(target);\n        const expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose))\n            return 'none';\n        return exclude ? 'excludeAll' : 'exposeAll';\n    }\n    getExposedMetadatas(target) {\n        return this.getMetadata(this._exposeMetadatas, target);\n    }\n    getExcludedMetadatas(target) {\n        return this.getMetadata(this._excludeMetadatas, target);\n    }\n    getExposedProperties(target, transformationType) {\n        return this.getExposedMetadatas(target)\n            .filter(metadata => {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(metadata => metadata.propertyName);\n    }\n    getExcludedProperties(target, transformationType) {\n        return this.getExcludedMetadatas(target)\n            .filter(metadata => {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(metadata => metadata.propertyName);\n    }\n    clear() {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    }\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    getMetadata(metadatas, target) {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n        }\n        const metadataFromAncestors = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n                metadataFromAncestors.push(...metadataFromAncestor);\n            }\n        }\n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    }\n    findMetadata(metadatas, target, propertyName) {\n        const metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                    return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    }\n    findMetadatas(metadatas, target, propertyName) {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);\n        }\n        const metadataFromAncestorsTarget = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                    metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return metadataFromAncestorsTarget\n            .slice()\n            .reverse()\n            .concat((metadataFromTarget || []).slice().reverse());\n    }\n    getAncestors(target) {\n        if (!target)\n            return [];\n        if (!this._ancestorsMap.has(target)) {\n            const ancestors = [];\n            for (let baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
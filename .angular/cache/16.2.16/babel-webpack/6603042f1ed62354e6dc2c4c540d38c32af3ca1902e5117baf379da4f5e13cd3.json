{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Injector = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst constants_1 = require(\"@nestjs/common/constants\");\nconst cli_colors_util_1 = require(\"@nestjs/common/utils/cli-colors.util\");\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst iterare_1 = require(\"iterare\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst exceptions_1 = require(\"../errors/exceptions\");\nconst runtime_exception_1 = require(\"../errors/exceptions/runtime.exception\");\nconst undefined_dependency_exception_1 = require(\"../errors/exceptions/undefined-dependency.exception\");\nconst unknown_dependencies_exception_1 = require(\"../errors/exceptions/unknown-dependencies.exception\");\nconst constants_2 = require(\"./constants\");\nconst inquirer_1 = require(\"./inquirer\");\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\nconst settlement_signal_1 = require(\"./settlement-signal\");\nclass Injector {\n  constructor(options) {\n    this.options = options;\n    this.logger = new common_1.Logger('InjectorLogger');\n  }\n  loadPrototype({\n    token\n  }, collection, contextId = constants_2.STATIC_CONTEXT) {\n    if (!collection) {\n      return;\n    }\n    const target = collection.get(token);\n    const instance = target.createPrototype(contextId);\n    if (instance) {\n      const wrapper = new instance_wrapper_1.InstanceWrapper({\n        ...target,\n        instance\n      });\n      collection.set(token, wrapper);\n    }\n  }\n  loadInstance(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const inquirerId = _this.getInquirerId(inquirer);\n      const instanceHost = wrapper.getInstanceByContextId(_this.getContextId(contextId, wrapper), inquirerId);\n      if (instanceHost.isPending) {\n        const settlementSignal = wrapper.settlementSignal;\n        if (inquirer && settlementSignal?.isCycle(inquirer.id)) {\n          throw new exceptions_1.CircularDependencyException(`\"${wrapper.name}\"`);\n        }\n        return instanceHost.donePromise.then(err => {\n          if (err) {\n            throw err;\n          }\n        });\n      }\n      const settlementSignal = _this.applySettlementSignal(instanceHost, wrapper);\n      const token = wrapper.token || wrapper.name;\n      const {\n        inject\n      } = wrapper;\n      const targetWrapper = collection.get(token);\n      if ((0, shared_utils_1.isUndefined)(targetWrapper)) {\n        throw new runtime_exception_1.RuntimeException();\n      }\n      if (instanceHost.isResolved) {\n        return settlementSignal.complete();\n      }\n      try {\n        const t0 = _this.getNowTimestamp();\n        const callback = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (instances) {\n            const properties = yield _this.resolveProperties(wrapper, moduleRef, inject, contextId, wrapper, inquirer);\n            const instance = yield _this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n            _this.applyProperties(instance, properties);\n            wrapper.initTime = _this.getNowTimestamp() - t0;\n            settlementSignal.complete();\n          });\n          return function callback(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        yield _this.resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId, wrapper, inquirer);\n      } catch (err) {\n        wrapper.removeInstanceByContextId(_this.getContextId(contextId, wrapper), inquirerId);\n        settlementSignal.error(err);\n        throw err;\n      }\n    })();\n  }\n  loadMiddleware(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        metatype,\n        token\n      } = wrapper;\n      const targetWrapper = collection.get(token);\n      if (!(0, shared_utils_1.isUndefined)(targetWrapper.instance)) {\n        return;\n      }\n      targetWrapper.instance = Object.create(metatype.prototype);\n      yield _this2.loadInstance(wrapper, collection, moduleRef, contextId, inquirer || wrapper);\n    })();\n  }\n  loadController(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const controllers = moduleRef.controllers;\n      yield _this3.loadInstance(wrapper, controllers, moduleRef, contextId, wrapper);\n      yield _this3.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    })();\n  }\n  loadInjectable(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const injectables = moduleRef.injectables;\n      yield _this4.loadInstance(wrapper, injectables, moduleRef, contextId, inquirer);\n    })();\n  }\n  loadProvider(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const providers = moduleRef.providers;\n      yield _this5.loadInstance(wrapper, providers, moduleRef, contextId, inquirer);\n      yield _this5.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    })();\n  }\n  applySettlementSignal(instancePerContext, host) {\n    const settlementSignal = new settlement_signal_1.SettlementSignal();\n    instancePerContext.donePromise = settlementSignal.asPromise();\n    instancePerContext.isPending = true;\n    host.settlementSignal = settlementSignal;\n    return settlementSignal;\n  }\n  resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      let inquirerId = _this6.getInquirerId(inquirer);\n      const metadata = wrapper.getCtorMetadata();\n      if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n        const deps = yield _this6.loadCtorMetadata(metadata, contextId, inquirer, parentInquirer);\n        return callback(deps);\n      }\n      const isFactoryProvider = !(0, shared_utils_1.isNil)(inject);\n      const [dependencies, optionalDependenciesIds] = isFactoryProvider ? _this6.getFactoryProviderDependencies(wrapper) : _this6.getClassDependencies(wrapper);\n      let isResolved = true;\n      const resolveParam = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (param, index) {\n          try {\n            if (_this6.isInquirer(param, parentInquirer)) {\n              return parentInquirer && parentInquirer.instance;\n            }\n            if (inquirer?.isTransient && parentInquirer) {\n              inquirer = parentInquirer;\n              inquirerId = _this6.getInquirerId(parentInquirer);\n            }\n            const paramWrapper = yield _this6.resolveSingleParam(wrapper, param, {\n              index,\n              dependencies\n            }, moduleRef, contextId, inquirer, index);\n            const instanceHost = paramWrapper.getInstanceByContextId(_this6.getContextId(contextId, paramWrapper), inquirerId);\n            if (!instanceHost.isResolved && !paramWrapper.forwardRef) {\n              isResolved = false;\n            }\n            return instanceHost?.instance;\n          } catch (err) {\n            const isOptional = optionalDependenciesIds.includes(index);\n            if (!isOptional) {\n              throw err;\n            }\n            return undefined;\n          }\n        });\n        return function resolveParam(_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const instances = yield Promise.all(dependencies.map(resolveParam));\n      isResolved && (yield callback(instances));\n    })();\n  }\n  getClassDependencies(wrapper) {\n    const ctorRef = wrapper.metatype;\n    return [this.reflectConstructorParams(ctorRef), this.reflectOptionalParams(ctorRef)];\n  }\n  getFactoryProviderDependencies(wrapper) {\n    const optionalDependenciesIds = [];\n    const isOptionalFactoryDep = item => !(0, shared_utils_1.isUndefined)(item.token) && !(0, shared_utils_1.isUndefined)(item.optional);\n    const mapFactoryProviderInjectArray = (item, index) => {\n      if (typeof item !== 'object') {\n        return item;\n      }\n      if (isOptionalFactoryDep(item)) {\n        if (item.optional) {\n          optionalDependenciesIds.push(index);\n        }\n        return item?.token;\n      }\n      return item;\n    };\n    return [wrapper.inject?.map?.(mapFactoryProviderInjectArray), optionalDependenciesIds];\n  }\n  reflectConstructorParams(type) {\n    const paramtypes = [...(Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type) || [])];\n    const selfParams = this.reflectSelfParams(type);\n    selfParams.forEach(({\n      index,\n      param\n    }) => paramtypes[index] = param);\n    return paramtypes;\n  }\n  reflectOptionalParams(type) {\n    return Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, type) || [];\n  }\n  reflectSelfParams(type) {\n    return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type) || [];\n  }\n  resolveSingleParam(wrapper, param, dependencyContext, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if ((0, shared_utils_1.isUndefined)(param)) {\n        _this7.logger.log('Nest encountered an undefined dependency. This may be due to a circular import or a missing dependency declaration.');\n        throw new undefined_dependency_exception_1.UndefinedDependencyException(wrapper.name, dependencyContext, moduleRef);\n      }\n      const token = _this7.resolveParamToken(wrapper, param);\n      return _this7.resolveComponentInstance(moduleRef, token, dependencyContext, wrapper, contextId, inquirer, keyOrIndex);\n    })();\n  }\n  resolveParamToken(wrapper, param) {\n    if (!param.forwardRef) {\n      return param;\n    }\n    wrapper.forwardRef = true;\n    return param.forwardRef();\n  }\n  resolveComponentInstance(moduleRef, token, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      _this8.printResolvingDependenciesLog(token, inquirer);\n      _this8.printLookingForProviderLog(token, moduleRef);\n      const providers = moduleRef.providers;\n      const instanceWrapper = yield _this8.lookupComponent(providers, moduleRef, {\n        ...dependencyContext,\n        name: token\n      }, wrapper, contextId, inquirer, keyOrIndex);\n      return _this8.resolveComponentHost(moduleRef, instanceWrapper, contextId, inquirer);\n    })();\n  }\n  resolveComponentHost(moduleRef, instanceWrapper, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const inquirerId = _this9.getInquirerId(inquirer);\n      const instanceHost = instanceWrapper.getInstanceByContextId(_this9.getContextId(contextId, instanceWrapper), inquirerId);\n      if (!instanceHost.isResolved && !instanceWrapper.forwardRef) {\n        inquirer?.settlementSignal?.insertRef(instanceWrapper.id);\n        yield _this9.loadProvider(instanceWrapper, instanceWrapper.host ?? moduleRef, contextId, inquirer);\n      } else if (!instanceHost.isResolved && instanceWrapper.forwardRef && (contextId !== constants_2.STATIC_CONTEXT || !!inquirerId)) {\n        /**\n         * When circular dependency has been detected between\n         * either request/transient providers, we have to asynchronously\n         * resolve instance host for a specific contextId or inquirer, to ensure\n         * that eventual lazily created instance will be merged with the prototype\n         * instantiated beforehand.\n         */\n        instanceHost.donePromise && instanceHost.donePromise.then(() => _this9.loadProvider(instanceWrapper, moduleRef, contextId, inquirer));\n      }\n      if (instanceWrapper.async) {\n        const host = instanceWrapper.getInstanceByContextId(_this9.getContextId(contextId, instanceWrapper), inquirerId);\n        host.instance = yield host.instance;\n        instanceWrapper.setInstanceByContextId(contextId, host, inquirerId);\n      }\n      return instanceWrapper;\n    })();\n  }\n  lookupComponent(providers, moduleRef, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const token = wrapper.token || wrapper.name;\n      const {\n        name\n      } = dependencyContext;\n      if (wrapper && token === name) {\n        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef, {\n          id: wrapper.id\n        });\n      }\n      if (providers.has(name)) {\n        const instanceWrapper = providers.get(name);\n        _this10.printFoundInModuleLog(name, moduleRef);\n        _this10.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapper);\n        return instanceWrapper;\n      }\n      return _this10.lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId, inquirer, keyOrIndex);\n    })();\n  }\n  lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const instanceWrapper = yield _this11.lookupComponentInImports(moduleRef, dependencyContext.name, wrapper, [], contextId, inquirer, keyOrIndex);\n      if ((0, shared_utils_1.isNil)(instanceWrapper)) {\n        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef, {\n          id: wrapper.id\n        });\n      }\n      return instanceWrapper;\n    })();\n  }\n  lookupComponentInImports(moduleRef, name, wrapper, moduleRegistry = [], contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex, isTraversing) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      let instanceWrapperRef = null;\n      const imports = moduleRef.imports || new Set();\n      const identity = item => item;\n      let children = [...imports.values()].filter(identity);\n      if (isTraversing) {\n        const contextModuleExports = moduleRef.exports;\n        children = children.filter(child => contextModuleExports.has(child.metatype));\n      }\n      for (const relatedModule of children) {\n        if (moduleRegistry.includes(relatedModule.id)) {\n          continue;\n        }\n        _this12.printLookingForProviderLog(name, relatedModule);\n        moduleRegistry.push(relatedModule.id);\n        const {\n          providers,\n          exports\n        } = relatedModule;\n        if (!exports.has(name) || !providers.has(name)) {\n          const instanceRef = yield _this12.lookupComponentInImports(relatedModule, name, wrapper, moduleRegistry, contextId, inquirer, keyOrIndex, true);\n          if (instanceRef) {\n            _this12.addDependencyMetadata(keyOrIndex, wrapper, instanceRef);\n            return instanceRef;\n          }\n          continue;\n        }\n        _this12.printFoundInModuleLog(name, relatedModule);\n        instanceWrapperRef = providers.get(name);\n        _this12.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapperRef);\n        const inquirerId = _this12.getInquirerId(inquirer);\n        const instanceHost = instanceWrapperRef.getInstanceByContextId(_this12.getContextId(contextId, instanceWrapperRef), inquirerId);\n        if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {\n          wrapper.settlementSignal?.insertRef(instanceWrapperRef.id);\n          yield _this12.loadProvider(instanceWrapperRef, relatedModule, contextId, wrapper);\n          break;\n        }\n      }\n      return instanceWrapperRef;\n    })();\n  }\n  resolveProperties(wrapper, moduleRef, inject, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!(0, shared_utils_1.isNil)(inject)) {\n        return [];\n      }\n      const metadata = wrapper.getPropertiesMetadata();\n      if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n        return _this13.loadPropertiesMetadata(metadata, contextId, inquirer);\n      }\n      const properties = _this13.reflectProperties(wrapper.metatype);\n      const instances = yield Promise.all(properties.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (item) {\n          try {\n            const dependencyContext = {\n              key: item.key,\n              name: item.name\n            };\n            if (_this13.isInquirer(item.name, parentInquirer)) {\n              return parentInquirer && parentInquirer.instance;\n            }\n            const paramWrapper = yield _this13.resolveSingleParam(wrapper, item.name, dependencyContext, moduleRef, contextId, inquirer, item.key);\n            if (!paramWrapper) {\n              return undefined;\n            }\n            const inquirerId = _this13.getInquirerId(inquirer);\n            const instanceHost = paramWrapper.getInstanceByContextId(_this13.getContextId(contextId, paramWrapper), inquirerId);\n            return instanceHost.instance;\n          } catch (err) {\n            if (!item.isOptional) {\n              throw err;\n            }\n            return undefined;\n          }\n        });\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return properties.map((item, index) => ({\n        ...item,\n        instance: instances[index]\n      }));\n    })();\n  }\n  reflectProperties(type) {\n    const properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, type) || [];\n    const optionalKeys = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];\n    return properties.map(item => ({\n      ...item,\n      name: item.type,\n      isOptional: optionalKeys.includes(item.key)\n    }));\n  }\n  applyProperties(instance, properties) {\n    if (!(0, shared_utils_1.isObject)(instance)) {\n      return undefined;\n    }\n    (0, iterare_1.iterate)(properties).filter(item => !(0, shared_utils_1.isNil)(item.instance)).forEach(item => instance[item.key] = item.instance);\n  }\n  instantiateClass(instances, wrapper, targetMetatype, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        metatype,\n        inject\n      } = wrapper;\n      const inquirerId = _this14.getInquirerId(inquirer);\n      const instanceHost = targetMetatype.getInstanceByContextId(_this14.getContextId(contextId, targetMetatype), inquirerId);\n      const isInContext = wrapper.isStatic(contextId, inquirer) || wrapper.isInRequestScope(contextId, inquirer) || wrapper.isLazyTransient(contextId, inquirer) || wrapper.isExplicitlyRequested(contextId, inquirer);\n      if (_this14.options?.preview && !wrapper.host?.initOnPreview) {\n        instanceHost.isResolved = true;\n        return instanceHost.instance;\n      }\n      if ((0, shared_utils_1.isNil)(inject) && isInContext) {\n        instanceHost.instance = wrapper.forwardRef ? Object.assign(instanceHost.instance, new metatype(...instances)) : new metatype(...instances);\n      } else if (isInContext) {\n        const factoryReturnValue = targetMetatype.metatype(...instances);\n        instanceHost.instance = yield factoryReturnValue;\n      }\n      instanceHost.isResolved = true;\n      return instanceHost.instance;\n    })();\n  }\n  loadPerContext(instance, moduleRef, collection, ctx, wrapper) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (!wrapper) {\n        const injectionToken = instance.constructor;\n        wrapper = collection.get(injectionToken);\n      }\n      yield _this15.loadInstance(wrapper, collection, moduleRef, ctx, wrapper);\n      yield _this15.loadEnhancersPerContext(wrapper, ctx, wrapper);\n      const host = wrapper.getInstanceByContextId(_this15.getContextId(ctx, wrapper), wrapper.id);\n      return host && host.instance;\n    })();\n  }\n  loadEnhancersPerContext(wrapper, ctx, inquirer) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const enhancers = wrapper.getEnhancersMetadata() || [];\n      const loadEnhancer = item => {\n        const hostModule = item.host;\n        return _this16.loadInstance(item, hostModule.injectables, hostModule, ctx, inquirer);\n      };\n      yield Promise.all(enhancers.map(loadEnhancer));\n    })();\n  }\n  loadCtorMetadata(metadata, contextId, inquirer, parentInquirer) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const hosts = yield Promise.all(metadata.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (item) {\n          return _this17.resolveScopedComponentHost(item, contextId, inquirer, parentInquirer);\n        });\n        return function (_x5) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      const inquirerId = _this17.getInquirerId(inquirer);\n      return hosts.map(item => item?.getInstanceByContextId(_this17.getContextId(contextId, item), inquirerId).instance);\n    })();\n  }\n  loadPropertiesMetadata(metadata, contextId, inquirer) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const dependenciesHosts = yield Promise.all(metadata.map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* ({\n          wrapper: item,\n          key\n        }) {\n          return {\n            key,\n            host: yield _this18.resolveComponentHost(item.host, item, contextId, inquirer)\n          };\n        });\n        return function (_x6) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      const inquirerId = _this18.getInquirerId(inquirer);\n      return dependenciesHosts.map(({\n        key,\n        host\n      }) => ({\n        key,\n        name: key,\n        instance: host.getInstanceByContextId(_this18.getContextId(contextId, host), inquirerId).instance\n      }));\n    })();\n  }\n  getInquirerId(inquirer) {\n    return inquirer && inquirer.id;\n  }\n  resolveScopedComponentHost(item, contextId, inquirer, parentInquirer) {\n    return this.isInquirerRequest(item, parentInquirer) ? parentInquirer : this.resolveComponentHost(item.host, item, contextId, inquirer);\n  }\n  isInquirerRequest(item, parentInquirer) {\n    return item.isTransient && item.name === inquirer_1.INQUIRER && parentInquirer;\n  }\n  isInquirer(param, parentInquirer) {\n    return param === inquirer_1.INQUIRER && parentInquirer;\n  }\n  addDependencyMetadata(keyOrIndex, hostWrapper, instanceWrapper) {\n    if ((0, shared_utils_1.isSymbol)(keyOrIndex) || (0, shared_utils_1.isString)(keyOrIndex)) {\n      hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper);\n    } else {\n      hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);\n    }\n  }\n  getTokenName(token) {\n    return (0, shared_utils_1.isFunction)(token) ? token.name : token.toString();\n  }\n  printResolvingDependenciesLog(token, inquirer) {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const dependentName = (inquirer?.name && inquirer.name.toString?.()) ?? 'unknown';\n    const isAlias = dependentName === tokenName;\n    const messageToPrint = `Resolving dependency ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in the ')}${cli_colors_util_1.clc.yellow(dependentName)}${cli_colors_util_1.clc.green(` provider ${isAlias ? '(alias)' : ''}`)}`;\n    this.logger.log(messageToPrint);\n  }\n  printLookingForProviderLog(token, moduleRef) {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n    this.logger.log(`Looking for ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in ')}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);\n  }\n  printFoundInModuleLog(token, moduleRef) {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n    this.logger.log(`Found ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in ')}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);\n  }\n  isDebugMode() {\n    return !!process.env.NEST_DEBUG;\n  }\n  getContextId(contextId, instanceWrapper) {\n    return contextId.getParent ? contextId.getParent({\n      token: instanceWrapper.token,\n      isTreeDurable: instanceWrapper.isDependencyTreeDurable()\n    }) : contextId;\n  }\n  getNowTimestamp() {\n    return perf_hooks_1.performance.now();\n  }\n}\nexports.Injector = Injector;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","Injector","common_1","constants_1","cli_colors_util_1","shared_utils_1","iterare_1","perf_hooks_1","exceptions_1","runtime_exception_1","undefined_dependency_exception_1","unknown_dependencies_exception_1","constants_2","inquirer_1","instance_wrapper_1","settlement_signal_1","constructor","options","logger","Logger","loadPrototype","token","collection","contextId","STATIC_CONTEXT","target","get","instance","createPrototype","wrapper","InstanceWrapper","set","loadInstance","moduleRef","inquirer","_this","inquirerId","getInquirerId","instanceHost","getInstanceByContextId","getContextId","isPending","settlementSignal","isCycle","id","CircularDependencyException","name","donePromise","then","err","applySettlementSignal","inject","targetWrapper","isUndefined","RuntimeException","isResolved","complete","t0","getNowTimestamp","callback","_ref","instances","properties","resolveProperties","instantiateClass","applyProperties","initTime","_x","apply","arguments","resolveConstructorParams","removeInstanceByContextId","error","loadMiddleware","_this2","metatype","create","prototype","loadController","_this3","controllers","loadEnhancersPerContext","loadInjectable","_this4","injectables","loadProvider","_this5","providers","instancePerContext","host","SettlementSignal","asPromise","parentInquirer","_this6","metadata","getCtorMetadata","deps","loadCtorMetadata","isFactoryProvider","isNil","dependencies","optionalDependenciesIds","getFactoryProviderDependencies","getClassDependencies","resolveParam","_ref2","param","index","isInquirer","isTransient","paramWrapper","resolveSingleParam","forwardRef","isOptional","includes","undefined","_x2","_x3","Promise","all","map","ctorRef","reflectConstructorParams","reflectOptionalParams","isOptionalFactoryDep","item","optional","mapFactoryProviderInjectArray","push","type","paramtypes","Reflect","getMetadata","PARAMTYPES_METADATA","selfParams","reflectSelfParams","forEach","OPTIONAL_DEPS_METADATA","SELF_DECLARED_DEPS_METADATA","dependencyContext","keyOrIndex","_this7","log","UndefinedDependencyException","resolveParamToken","resolveComponentInstance","_this8","printResolvingDependenciesLog","printLookingForProviderLog","instanceWrapper","lookupComponent","resolveComponentHost","_this9","insertRef","async","setInstanceByContextId","_this10","UnknownDependenciesException","has","printFoundInModuleLog","addDependencyMetadata","lookupComponentInParentModules","_this11","lookupComponentInImports","moduleRegistry","isTraversing","_this12","instanceWrapperRef","imports","Set","identity","children","values","filter","contextModuleExports","child","relatedModule","instanceRef","_this13","getPropertiesMetadata","loadPropertiesMetadata","reflectProperties","_ref3","key","_x4","PROPERTY_DEPS_METADATA","optionalKeys","OPTIONAL_PROPERTY_DEPS_METADATA","isObject","iterate","targetMetatype","_this14","isInContext","isStatic","isInRequestScope","isLazyTransient","isExplicitlyRequested","preview","initOnPreview","assign","factoryReturnValue","loadPerContext","ctx","_this15","injectionToken","_this16","enhancers","getEnhancersMetadata","loadEnhancer","hostModule","_this17","hosts","_ref4","resolveScopedComponentHost","_x5","_this18","dependenciesHosts","_ref5","_x6","isInquirerRequest","INQUIRER","hostWrapper","isSymbol","isString","addPropertiesMetadata","addCtorMetadata","getTokenName","isFunction","toString","isDebugMode","tokenName","dependentName","isAlias","messageToPrint","clc","cyanBright","green","yellow","moduleRefName","magentaBright","process","env","NEST_DEBUG","getParent","isTreeDurable","isDependencyTreeDurable","performance","now"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/core/injector/injector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Injector = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst constants_1 = require(\"@nestjs/common/constants\");\nconst cli_colors_util_1 = require(\"@nestjs/common/utils/cli-colors.util\");\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst iterare_1 = require(\"iterare\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst exceptions_1 = require(\"../errors/exceptions\");\nconst runtime_exception_1 = require(\"../errors/exceptions/runtime.exception\");\nconst undefined_dependency_exception_1 = require(\"../errors/exceptions/undefined-dependency.exception\");\nconst unknown_dependencies_exception_1 = require(\"../errors/exceptions/unknown-dependencies.exception\");\nconst constants_2 = require(\"./constants\");\nconst inquirer_1 = require(\"./inquirer\");\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\nconst settlement_signal_1 = require(\"./settlement-signal\");\nclass Injector {\n    constructor(options) {\n        this.options = options;\n        this.logger = new common_1.Logger('InjectorLogger');\n    }\n    loadPrototype({ token }, collection, contextId = constants_2.STATIC_CONTEXT) {\n        if (!collection) {\n            return;\n        }\n        const target = collection.get(token);\n        const instance = target.createPrototype(contextId);\n        if (instance) {\n            const wrapper = new instance_wrapper_1.InstanceWrapper({\n                ...target,\n                instance,\n            });\n            collection.set(token, wrapper);\n        }\n    }\n    async loadInstance(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const inquirerId = this.getInquirerId(inquirer);\n        const instanceHost = wrapper.getInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId);\n        if (instanceHost.isPending) {\n            const settlementSignal = wrapper.settlementSignal;\n            if (inquirer && settlementSignal?.isCycle(inquirer.id)) {\n                throw new exceptions_1.CircularDependencyException(`\"${wrapper.name}\"`);\n            }\n            return instanceHost.donePromise.then((err) => {\n                if (err) {\n                    throw err;\n                }\n            });\n        }\n        const settlementSignal = this.applySettlementSignal(instanceHost, wrapper);\n        const token = wrapper.token || wrapper.name;\n        const { inject } = wrapper;\n        const targetWrapper = collection.get(token);\n        if ((0, shared_utils_1.isUndefined)(targetWrapper)) {\n            throw new runtime_exception_1.RuntimeException();\n        }\n        if (instanceHost.isResolved) {\n            return settlementSignal.complete();\n        }\n        try {\n            const t0 = this.getNowTimestamp();\n            const callback = async (instances) => {\n                const properties = await this.resolveProperties(wrapper, moduleRef, inject, contextId, wrapper, inquirer);\n                const instance = await this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n                this.applyProperties(instance, properties);\n                wrapper.initTime = this.getNowTimestamp() - t0;\n                settlementSignal.complete();\n            };\n            await this.resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId, wrapper, inquirer);\n        }\n        catch (err) {\n            wrapper.removeInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId);\n            settlementSignal.error(err);\n            throw err;\n        }\n    }\n    async loadMiddleware(wrapper, collection, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const { metatype, token } = wrapper;\n        const targetWrapper = collection.get(token);\n        if (!(0, shared_utils_1.isUndefined)(targetWrapper.instance)) {\n            return;\n        }\n        targetWrapper.instance = Object.create(metatype.prototype);\n        await this.loadInstance(wrapper, collection, moduleRef, contextId, inquirer || wrapper);\n    }\n    async loadController(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT) {\n        const controllers = moduleRef.controllers;\n        await this.loadInstance(wrapper, controllers, moduleRef, contextId, wrapper);\n        await this.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    }\n    async loadInjectable(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const injectables = moduleRef.injectables;\n        await this.loadInstance(wrapper, injectables, moduleRef, contextId, inquirer);\n    }\n    async loadProvider(wrapper, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const providers = moduleRef.providers;\n        await this.loadInstance(wrapper, providers, moduleRef, contextId, inquirer);\n        await this.loadEnhancersPerContext(wrapper, contextId, wrapper);\n    }\n    applySettlementSignal(instancePerContext, host) {\n        const settlementSignal = new settlement_signal_1.SettlementSignal();\n        instancePerContext.donePromise = settlementSignal.asPromise();\n        instancePerContext.isPending = true;\n        host.settlementSignal = settlementSignal;\n        return settlementSignal;\n    }\n    async resolveConstructorParams(wrapper, moduleRef, inject, callback, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n        let inquirerId = this.getInquirerId(inquirer);\n        const metadata = wrapper.getCtorMetadata();\n        if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n            const deps = await this.loadCtorMetadata(metadata, contextId, inquirer, parentInquirer);\n            return callback(deps);\n        }\n        const isFactoryProvider = !(0, shared_utils_1.isNil)(inject);\n        const [dependencies, optionalDependenciesIds] = isFactoryProvider\n            ? this.getFactoryProviderDependencies(wrapper)\n            : this.getClassDependencies(wrapper);\n        let isResolved = true;\n        const resolveParam = async (param, index) => {\n            try {\n                if (this.isInquirer(param, parentInquirer)) {\n                    return parentInquirer && parentInquirer.instance;\n                }\n                if (inquirer?.isTransient && parentInquirer) {\n                    inquirer = parentInquirer;\n                    inquirerId = this.getInquirerId(parentInquirer);\n                }\n                const paramWrapper = await this.resolveSingleParam(wrapper, param, { index, dependencies }, moduleRef, contextId, inquirer, index);\n                const instanceHost = paramWrapper.getInstanceByContextId(this.getContextId(contextId, paramWrapper), inquirerId);\n                if (!instanceHost.isResolved && !paramWrapper.forwardRef) {\n                    isResolved = false;\n                }\n                return instanceHost?.instance;\n            }\n            catch (err) {\n                const isOptional = optionalDependenciesIds.includes(index);\n                if (!isOptional) {\n                    throw err;\n                }\n                return undefined;\n            }\n        };\n        const instances = await Promise.all(dependencies.map(resolveParam));\n        isResolved && (await callback(instances));\n    }\n    getClassDependencies(wrapper) {\n        const ctorRef = wrapper.metatype;\n        return [\n            this.reflectConstructorParams(ctorRef),\n            this.reflectOptionalParams(ctorRef),\n        ];\n    }\n    getFactoryProviderDependencies(wrapper) {\n        const optionalDependenciesIds = [];\n        const isOptionalFactoryDep = (item) => !(0, shared_utils_1.isUndefined)(item.token) &&\n            !(0, shared_utils_1.isUndefined)(item.optional);\n        const mapFactoryProviderInjectArray = (item, index) => {\n            if (typeof item !== 'object') {\n                return item;\n            }\n            if (isOptionalFactoryDep(item)) {\n                if (item.optional) {\n                    optionalDependenciesIds.push(index);\n                }\n                return item?.token;\n            }\n            return item;\n        };\n        return [\n            wrapper.inject?.map?.(mapFactoryProviderInjectArray),\n            optionalDependenciesIds,\n        ];\n    }\n    reflectConstructorParams(type) {\n        const paramtypes = [\n            ...(Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type) || []),\n        ];\n        const selfParams = this.reflectSelfParams(type);\n        selfParams.forEach(({ index, param }) => (paramtypes[index] = param));\n        return paramtypes;\n    }\n    reflectOptionalParams(type) {\n        return Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, type) || [];\n    }\n    reflectSelfParams(type) {\n        return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type) || [];\n    }\n    async resolveSingleParam(wrapper, param, dependencyContext, moduleRef, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n        if ((0, shared_utils_1.isUndefined)(param)) {\n            this.logger.log('Nest encountered an undefined dependency. This may be due to a circular import or a missing dependency declaration.');\n            throw new undefined_dependency_exception_1.UndefinedDependencyException(wrapper.name, dependencyContext, moduleRef);\n        }\n        const token = this.resolveParamToken(wrapper, param);\n        return this.resolveComponentInstance(moduleRef, token, dependencyContext, wrapper, contextId, inquirer, keyOrIndex);\n    }\n    resolveParamToken(wrapper, param) {\n        if (!param.forwardRef) {\n            return param;\n        }\n        wrapper.forwardRef = true;\n        return param.forwardRef();\n    }\n    async resolveComponentInstance(moduleRef, token, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n        this.printResolvingDependenciesLog(token, inquirer);\n        this.printLookingForProviderLog(token, moduleRef);\n        const providers = moduleRef.providers;\n        const instanceWrapper = await this.lookupComponent(providers, moduleRef, { ...dependencyContext, name: token }, wrapper, contextId, inquirer, keyOrIndex);\n        return this.resolveComponentHost(moduleRef, instanceWrapper, contextId, inquirer);\n    }\n    async resolveComponentHost(moduleRef, instanceWrapper, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const inquirerId = this.getInquirerId(inquirer);\n        const instanceHost = instanceWrapper.getInstanceByContextId(this.getContextId(contextId, instanceWrapper), inquirerId);\n        if (!instanceHost.isResolved && !instanceWrapper.forwardRef) {\n            inquirer?.settlementSignal?.insertRef(instanceWrapper.id);\n            await this.loadProvider(instanceWrapper, instanceWrapper.host ?? moduleRef, contextId, inquirer);\n        }\n        else if (!instanceHost.isResolved &&\n            instanceWrapper.forwardRef &&\n            (contextId !== constants_2.STATIC_CONTEXT || !!inquirerId)) {\n            /**\n             * When circular dependency has been detected between\n             * either request/transient providers, we have to asynchronously\n             * resolve instance host for a specific contextId or inquirer, to ensure\n             * that eventual lazily created instance will be merged with the prototype\n             * instantiated beforehand.\n             */\n            instanceHost.donePromise &&\n                instanceHost.donePromise.then(() => this.loadProvider(instanceWrapper, moduleRef, contextId, inquirer));\n        }\n        if (instanceWrapper.async) {\n            const host = instanceWrapper.getInstanceByContextId(this.getContextId(contextId, instanceWrapper), inquirerId);\n            host.instance = await host.instance;\n            instanceWrapper.setInstanceByContextId(contextId, host, inquirerId);\n        }\n        return instanceWrapper;\n    }\n    async lookupComponent(providers, moduleRef, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n        const token = wrapper.token || wrapper.name;\n        const { name } = dependencyContext;\n        if (wrapper && token === name) {\n            throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef, { id: wrapper.id });\n        }\n        if (providers.has(name)) {\n            const instanceWrapper = providers.get(name);\n            this.printFoundInModuleLog(name, moduleRef);\n            this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapper);\n            return instanceWrapper;\n        }\n        return this.lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId, inquirer, keyOrIndex);\n    }\n    async lookupComponentInParentModules(dependencyContext, moduleRef, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex) {\n        const instanceWrapper = await this.lookupComponentInImports(moduleRef, dependencyContext.name, wrapper, [], contextId, inquirer, keyOrIndex);\n        if ((0, shared_utils_1.isNil)(instanceWrapper)) {\n            throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef, { id: wrapper.id });\n        }\n        return instanceWrapper;\n    }\n    async lookupComponentInImports(moduleRef, name, wrapper, moduleRegistry = [], contextId = constants_2.STATIC_CONTEXT, inquirer, keyOrIndex, isTraversing) {\n        let instanceWrapperRef = null;\n        const imports = moduleRef.imports || new Set();\n        const identity = (item) => item;\n        let children = [...imports.values()].filter(identity);\n        if (isTraversing) {\n            const contextModuleExports = moduleRef.exports;\n            children = children.filter(child => contextModuleExports.has(child.metatype));\n        }\n        for (const relatedModule of children) {\n            if (moduleRegistry.includes(relatedModule.id)) {\n                continue;\n            }\n            this.printLookingForProviderLog(name, relatedModule);\n            moduleRegistry.push(relatedModule.id);\n            const { providers, exports } = relatedModule;\n            if (!exports.has(name) || !providers.has(name)) {\n                const instanceRef = await this.lookupComponentInImports(relatedModule, name, wrapper, moduleRegistry, contextId, inquirer, keyOrIndex, true);\n                if (instanceRef) {\n                    this.addDependencyMetadata(keyOrIndex, wrapper, instanceRef);\n                    return instanceRef;\n                }\n                continue;\n            }\n            this.printFoundInModuleLog(name, relatedModule);\n            instanceWrapperRef = providers.get(name);\n            this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapperRef);\n            const inquirerId = this.getInquirerId(inquirer);\n            const instanceHost = instanceWrapperRef.getInstanceByContextId(this.getContextId(contextId, instanceWrapperRef), inquirerId);\n            if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {\n                wrapper.settlementSignal?.insertRef(instanceWrapperRef.id);\n                await this.loadProvider(instanceWrapperRef, relatedModule, contextId, wrapper);\n                break;\n            }\n        }\n        return instanceWrapperRef;\n    }\n    async resolveProperties(wrapper, moduleRef, inject, contextId = constants_2.STATIC_CONTEXT, inquirer, parentInquirer) {\n        if (!(0, shared_utils_1.isNil)(inject)) {\n            return [];\n        }\n        const metadata = wrapper.getPropertiesMetadata();\n        if (metadata && contextId !== constants_2.STATIC_CONTEXT) {\n            return this.loadPropertiesMetadata(metadata, contextId, inquirer);\n        }\n        const properties = this.reflectProperties(wrapper.metatype);\n        const instances = await Promise.all(properties.map(async (item) => {\n            try {\n                const dependencyContext = {\n                    key: item.key,\n                    name: item.name,\n                };\n                if (this.isInquirer(item.name, parentInquirer)) {\n                    return parentInquirer && parentInquirer.instance;\n                }\n                const paramWrapper = await this.resolveSingleParam(wrapper, item.name, dependencyContext, moduleRef, contextId, inquirer, item.key);\n                if (!paramWrapper) {\n                    return undefined;\n                }\n                const inquirerId = this.getInquirerId(inquirer);\n                const instanceHost = paramWrapper.getInstanceByContextId(this.getContextId(contextId, paramWrapper), inquirerId);\n                return instanceHost.instance;\n            }\n            catch (err) {\n                if (!item.isOptional) {\n                    throw err;\n                }\n                return undefined;\n            }\n        }));\n        return properties.map((item, index) => ({\n            ...item,\n            instance: instances[index],\n        }));\n    }\n    reflectProperties(type) {\n        const properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, type) || [];\n        const optionalKeys = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];\n        return properties.map((item) => ({\n            ...item,\n            name: item.type,\n            isOptional: optionalKeys.includes(item.key),\n        }));\n    }\n    applyProperties(instance, properties) {\n        if (!(0, shared_utils_1.isObject)(instance)) {\n            return undefined;\n        }\n        (0, iterare_1.iterate)(properties)\n            .filter(item => !(0, shared_utils_1.isNil)(item.instance))\n            .forEach(item => (instance[item.key] = item.instance));\n    }\n    async instantiateClass(instances, wrapper, targetMetatype, contextId = constants_2.STATIC_CONTEXT, inquirer) {\n        const { metatype, inject } = wrapper;\n        const inquirerId = this.getInquirerId(inquirer);\n        const instanceHost = targetMetatype.getInstanceByContextId(this.getContextId(contextId, targetMetatype), inquirerId);\n        const isInContext = wrapper.isStatic(contextId, inquirer) ||\n            wrapper.isInRequestScope(contextId, inquirer) ||\n            wrapper.isLazyTransient(contextId, inquirer) ||\n            wrapper.isExplicitlyRequested(contextId, inquirer);\n        if (this.options?.preview && !wrapper.host?.initOnPreview) {\n            instanceHost.isResolved = true;\n            return instanceHost.instance;\n        }\n        if ((0, shared_utils_1.isNil)(inject) && isInContext) {\n            instanceHost.instance = wrapper.forwardRef\n                ? Object.assign(instanceHost.instance, new metatype(...instances))\n                : new metatype(...instances);\n        }\n        else if (isInContext) {\n            const factoryReturnValue = targetMetatype.metatype(...instances);\n            instanceHost.instance = await factoryReturnValue;\n        }\n        instanceHost.isResolved = true;\n        return instanceHost.instance;\n    }\n    async loadPerContext(instance, moduleRef, collection, ctx, wrapper) {\n        if (!wrapper) {\n            const injectionToken = instance.constructor;\n            wrapper = collection.get(injectionToken);\n        }\n        await this.loadInstance(wrapper, collection, moduleRef, ctx, wrapper);\n        await this.loadEnhancersPerContext(wrapper, ctx, wrapper);\n        const host = wrapper.getInstanceByContextId(this.getContextId(ctx, wrapper), wrapper.id);\n        return host && host.instance;\n    }\n    async loadEnhancersPerContext(wrapper, ctx, inquirer) {\n        const enhancers = wrapper.getEnhancersMetadata() || [];\n        const loadEnhancer = (item) => {\n            const hostModule = item.host;\n            return this.loadInstance(item, hostModule.injectables, hostModule, ctx, inquirer);\n        };\n        await Promise.all(enhancers.map(loadEnhancer));\n    }\n    async loadCtorMetadata(metadata, contextId, inquirer, parentInquirer) {\n        const hosts = await Promise.all(metadata.map(async (item) => this.resolveScopedComponentHost(item, contextId, inquirer, parentInquirer)));\n        const inquirerId = this.getInquirerId(inquirer);\n        return hosts.map(item => item?.getInstanceByContextId(this.getContextId(contextId, item), inquirerId).instance);\n    }\n    async loadPropertiesMetadata(metadata, contextId, inquirer) {\n        const dependenciesHosts = await Promise.all(metadata.map(async ({ wrapper: item, key }) => ({\n            key,\n            host: await this.resolveComponentHost(item.host, item, contextId, inquirer),\n        })));\n        const inquirerId = this.getInquirerId(inquirer);\n        return dependenciesHosts.map(({ key, host }) => ({\n            key,\n            name: key,\n            instance: host.getInstanceByContextId(this.getContextId(contextId, host), inquirerId).instance,\n        }));\n    }\n    getInquirerId(inquirer) {\n        return inquirer && inquirer.id;\n    }\n    resolveScopedComponentHost(item, contextId, inquirer, parentInquirer) {\n        return this.isInquirerRequest(item, parentInquirer)\n            ? parentInquirer\n            : this.resolveComponentHost(item.host, item, contextId, inquirer);\n    }\n    isInquirerRequest(item, parentInquirer) {\n        return item.isTransient && item.name === inquirer_1.INQUIRER && parentInquirer;\n    }\n    isInquirer(param, parentInquirer) {\n        return param === inquirer_1.INQUIRER && parentInquirer;\n    }\n    addDependencyMetadata(keyOrIndex, hostWrapper, instanceWrapper) {\n        if ((0, shared_utils_1.isSymbol)(keyOrIndex) || (0, shared_utils_1.isString)(keyOrIndex)) {\n            hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper);\n        }\n        else {\n            hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);\n        }\n    }\n    getTokenName(token) {\n        return (0, shared_utils_1.isFunction)(token) ? token.name : token.toString();\n    }\n    printResolvingDependenciesLog(token, inquirer) {\n        if (!this.isDebugMode()) {\n            return;\n        }\n        const tokenName = this.getTokenName(token);\n        const dependentName = (inquirer?.name && inquirer.name.toString?.()) ?? 'unknown';\n        const isAlias = dependentName === tokenName;\n        const messageToPrint = `Resolving dependency ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in the ')}${cli_colors_util_1.clc.yellow(dependentName)}${cli_colors_util_1.clc.green(` provider ${isAlias ? '(alias)' : ''}`)}`;\n        this.logger.log(messageToPrint);\n    }\n    printLookingForProviderLog(token, moduleRef) {\n        if (!this.isDebugMode()) {\n            return;\n        }\n        const tokenName = this.getTokenName(token);\n        const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n        this.logger.log(`Looking for ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in ')}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);\n    }\n    printFoundInModuleLog(token, moduleRef) {\n        if (!this.isDebugMode()) {\n            return;\n        }\n        const tokenName = this.getTokenName(token);\n        const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n        this.logger.log(`Found ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(' in ')}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);\n    }\n    isDebugMode() {\n        return !!process.env.NEST_DEBUG;\n    }\n    getContextId(contextId, instanceWrapper) {\n        return contextId.getParent\n            ? contextId.getParent({\n                token: instanceWrapper.token,\n                isTreeDurable: instanceWrapper.isDependencyTreeDurable(),\n            })\n            : contextId;\n    }\n    getNowTimestamp() {\n        return perf_hooks_1.performance.now();\n    }\n}\nexports.Injector = Injector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { ValidationError } from './ValidationError';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(validator, validatorOptions) {\n    this.validator = validator;\n    this.validatorOptions = validatorOptions;\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this.awaitingPromises = [];\n    this.ignoreAsyncValidations = false;\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n    this.metadataStorage = getMetadataStorage();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  execute(object, targetSchema, validationErrors) {\n    var _a, _b;\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n    if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {\n      console.warn(`No validation metadata found. No validation will be  performed. There are multiple possible reasons:\\n` + `  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\\n` + `  - This validation runs before any file with validation decorator was parsed by NodeJS.`);\n    }\n    const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    const strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;\n    const always = this.validatorOptions && this.validatorOptions.always || false;\n    /** Forbid unknown values are turned on by default and any other value than false will enable it. */\n    const forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === undefined || this.validatorOptions.forbidUnknownValues !== false;\n    const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);\n    const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n    if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {\n      const validationError = new ValidationError();\n      if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = {\n        unknownValue: 'an unknown value was passed to the validate function'\n      };\n      validationErrors.push(validationError);\n      return;\n    }\n    if (this.validatorOptions && this.validatorOptions.whitelist) this.whitelist(object, groupedMetadatas, validationErrors);\n    // General validation\n    Object.keys(groupedMetadatas).forEach(propertyName => {\n      const value = object[propertyName];\n      const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n      const metadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n      if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n        this.awaitingPromises.push(value.then(resolvedValue => {\n          this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n        }));\n      } else {\n        this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  }\n  whitelist(object, groupedMetadatas, validationErrors) {\n    const notAllowedProperties = [];\n    Object.keys(object).forEach(propertyName => {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0) notAllowedProperties.push(propertyName);\n    });\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(property => {\n          const validationError = this.generateValidationError(object, object[property], property);\n          validationError.constraints = {\n            [ValidationTypes.WHITELIST]: `property ${property} should not exist`\n          };\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(property => delete object[property]);\n      }\n    }\n  }\n  stripEmptyErrors(errors) {\n    return errors.filter(error => {\n      if (error.children) {\n        error.children = this.stripEmptyErrors(error.children);\n      }\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n      return true;\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {\n    const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n    const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n    const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n    const validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n    const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n    if (!canValidate) {\n      return;\n    }\n    // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n    if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n      return;\n    }\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError);\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  }\n  generateValidationError(object, value, propertyName) {\n    const validationError = new ValidationError();\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === undefined || this.validatorOptions.validationError.value === true) validationError.value = value;\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n    return validationError;\n  }\n  conditionalValidations(object, value, metadatas) {\n    return metadatas.map(metadata => metadata.constraints[0](object, value)).reduce((resultA, resultB) => resultA && resultB, true);\n  }\n  customValidations(object, value, metadatas, error) {\n    metadatas.forEach(metadata => {\n      this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n        if (customConstraintMetadata.async && this.ignoreAsyncValidations) return;\n        if (this.validatorOptions && this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) return;\n        const validationArguments = {\n          targetName: object.constructor ? object.constructor.name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints\n        };\n        if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n          const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n          if (isPromise(validatedValue)) {\n            const promise = validatedValue.then(isValid => {\n              if (!isValid) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n            }\n          }\n          return;\n        }\n        // convert set and map into array\n        const arrayValue = convertToArray(value);\n        // Validation needs to be applied to each array item\n        const validatedSubValues = arrayValue.map(subValue => customConstraintMetadata.instance.validate(subValue, validationArguments));\n        const validationIsAsync = validatedSubValues.some(validatedSubValue => isPromise(validatedSubValue));\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          const asyncValidatedSubValues = validatedSubValues.map(validatedSubValue => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n          const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(flatValidatedValues => {\n            const validationResult = flatValidatedValues.every(isValid => isValid);\n            if (!validationResult) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n              if (metadata.context) {\n                if (!error.contexts) {\n                  error.contexts = {};\n                }\n                error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n              }\n            }\n          });\n          this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n          return;\n        }\n        const validationResult = validatedSubValues.every(isValid => isValid);\n        if (!validationResult) {\n          const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n          error.constraints[type] = message;\n        }\n      });\n    });\n  }\n  nestedValidations(value, metadatas, error) {\n    if (value === void 0) {\n      return;\n    }\n    metadatas.forEach(metadata => {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      } else if (this.validatorOptions && this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) {\n        return;\n      }\n      if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach((subValue, index) => {\n          this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);\n        });\n      } else if (value instanceof Object) {\n        const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        this.execute(value, targetSchema, error.children);\n      } else {\n        const [type, message] = this.createValidationError(metadata.target, value, metadata);\n        error.constraints[type] = message;\n      }\n    });\n  }\n  mapContexts(object, value, metadatas, error) {\n    return metadatas.forEach(metadata => {\n      if (metadata.context) {\n        let customConstraint;\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n        const type = this.getConstraintType(metadata, customConstraint);\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  }\n  createValidationError(object, value, metadata, customValidatorMetadata) {\n    const targetName = object.constructor ? object.constructor.name : undefined;\n    const type = this.getConstraintType(metadata, customValidatorMetadata);\n    const validationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints\n    };\n    let message = metadata.message || '';\n    if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n    const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  }\n  getConstraintType(metadata, customValidatorMetadata) {\n    const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  }\n}","map":{"version":3,"names":["ValidationError","ValidationTypes","ValidationUtils","isPromise","convertToArray","getMetadataStorage","ValidationExecutor","constructor","validator","validatorOptions","awaitingPromises","ignoreAsyncValidations","metadataStorage","execute","object","targetSchema","validationErrors","_a","_b","hasValidationMetaData","enableDebugMessages","console","warn","groups","undefined","strictGroups","always","forbidUnknownValues","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","length","validationError","target","value","property","children","constraints","unknownValue","push","whitelist","Object","keys","forEach","propertyName","definedMetadatas","filter","metadata","type","IS_DEFINED","metadatas","WHITELIST","Promise","find","PROMISE_VALIDATION","then","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","stripEmptyErrors","errors","error","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","canValidate","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","map","reduce","resultA","resultB","getTargetValidatorConstraints","constraintCls","customConstraintMetadata","async","stopAtFirstError","validationArguments","targetName","name","each","Array","isArray","Set","Map","validatedValue","instance","validate","promise","isValid","message","createValidationError","context","contexts","assign","arrayValue","validatedSubValues","subValue","validationIsAsync","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","validationResult","every","arrayLikeValue","from","index","toString","customConstraint","customConstraints","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","Function","messageString","replaceMessageSpecialTokens"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/class-validator/esm2015/validation/ValidationExecutor.js"],"sourcesContent":["import { ValidationError } from './ValidationError';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(validator, validatorOptions) {\n        this.validator = validator;\n        this.validatorOptions = validatorOptions;\n        // -------------------------------------------------------------------------\n        // Properties\n        // -------------------------------------------------------------------------\n        this.awaitingPromises = [];\n        this.ignoreAsyncValidations = false;\n        // -------------------------------------------------------------------------\n        // Private Properties\n        // -------------------------------------------------------------------------\n        this.metadataStorage = getMetadataStorage();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    execute(object, targetSchema, validationErrors) {\n        var _a, _b;\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {\n            console.warn(`No validation metadata found. No validation will be  performed. There are multiple possible reasons:\\n` +\n                `  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\\n` +\n                `  - This validation runs before any file with validation decorator was parsed by NodeJS.`);\n        }\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const strictGroups = (this.validatorOptions && this.validatorOptions.strictGroups) || false;\n        const always = (this.validatorOptions && this.validatorOptions.always) || false;\n        /** Forbid unknown values are turned on by default and any other value than false will enable it. */\n        const forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === undefined || this.validatorOptions.forbidUnknownValues !== false;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n        if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: 'an unknown value was passed to the validate function' };\n            validationErrors.push(validationError);\n            return;\n        }\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = object[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n            if (value instanceof Promise &&\n                metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then(resolvedValue => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            }\n            else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n    whitelist(object, groupedMetadatas, validationErrors) {\n        const notAllowedProperties = [];\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n        if (notAllowedProperties.length > 0) {\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError = this.generateValidationError(object, object[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n            }\n            else {\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete object[property]);\n            }\n        }\n    }\n    stripEmptyErrors(errors) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                }\n                else {\n                    delete error.constraints;\n                }\n            }\n            return true;\n        });\n    }\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n        if ((value === null || value === undefined) &&\n            this.validatorOptions &&\n            this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError);\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n    generateValidationError(object, value, propertyName) {\n        const validationError = new ValidationError();\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n        return validationError;\n    }\n    conditionalValidations(object, value, metadatas) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n    customValidations(object, value, metadatas, error) {\n        metadatas.forEach(metadata => {\n            this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n                if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                    return;\n                if (this.validatorOptions &&\n                    this.validatorOptions.stopAtFirstError &&\n                    Object.keys(error.constraints || {}).length > 0)\n                    return;\n                const validationArguments = {\n                    targetName: object.constructor ? object.constructor.name : undefined,\n                    property: metadata.propertyName,\n                    object: object,\n                    value: value,\n                    constraints: metadata.constraints,\n                };\n                if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n                    const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                    if (isPromise(validatedValue)) {\n                        const promise = validatedValue.then(isValid => {\n                            if (!isValid) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                                if (metadata.context) {\n                                    if (!error.contexts) {\n                                        error.contexts = {};\n                                    }\n                                    error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                                }\n                            }\n                        });\n                        this.awaitingPromises.push(promise);\n                    }\n                    else {\n                        if (!validatedValue) {\n                            const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                            error.constraints[type] = message;\n                        }\n                    }\n                    return;\n                }\n                // convert set and map into array\n                const arrayValue = convertToArray(value);\n                // Validation needs to be applied to each array item\n                const validatedSubValues = arrayValue.map((subValue) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                const validationIsAsync = validatedSubValues.some((validatedSubValue) => isPromise(validatedSubValue));\n                if (validationIsAsync) {\n                    // Wrap plain values (if any) in promises, so that all are async\n                    const asyncValidatedSubValues = validatedSubValues.map((validatedSubValue) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                    const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then((flatValidatedValues) => {\n                        const validationResult = flatValidatedValues.every((isValid) => isValid);\n                        if (!validationResult) {\n                            const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                            error.constraints[type] = message;\n                            if (metadata.context) {\n                                if (!error.contexts) {\n                                    error.contexts = {};\n                                }\n                                error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                            }\n                        }\n                    });\n                    this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n                    return;\n                }\n                const validationResult = validatedSubValues.every((isValid) => isValid);\n                if (!validationResult) {\n                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                    error.constraints[type] = message;\n                }\n            });\n        });\n    }\n    nestedValidations(value, metadatas, error) {\n        if (value === void 0) {\n            return;\n        }\n        metadatas.forEach(metadata => {\n            if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n                return;\n            }\n            else if (this.validatorOptions &&\n                this.validatorOptions.stopAtFirstError &&\n                Object.keys(error.constraints || {}).length > 0) {\n                return;\n            }\n            if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue, index) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);\n                });\n            }\n            else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n                this.execute(value, targetSchema, error.children);\n            }\n            else {\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints[type] = message;\n            }\n        });\n    }\n    mapContexts(object, value, metadatas, error) {\n        return metadatas.forEach(metadata => {\n            if (metadata.context) {\n                let customConstraint;\n                if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                    const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                    customConstraint = customConstraints[0];\n                }\n                const type = this.getConstraintType(metadata, customConstraint);\n                if (error.constraints[type]) {\n                    if (!error.contexts) {\n                        error.contexts = {};\n                    }\n                    error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n            }\n        });\n    }\n    createValidationError(object, value, metadata, customValidatorMetadata) {\n        const targetName = object.constructor ? object.constructor.name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints,\n        };\n        let message = metadata.message || '';\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n    getConstraintType(metadata, customValidatorMetadata) {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
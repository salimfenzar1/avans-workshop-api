{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefinitionsFactory = void 0;\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst mongoose = require(\"mongoose\");\nconst type_metadata_storage_1 = require(\"../storages/type-metadata.storage\");\nconst BUILT_IN_TYPES = [Boolean, Number, String, Map, Date, Buffer, BigInt];\nclass DefinitionsFactory {\n  static createForClass(target) {\n    if (!target) {\n      throw new Error(`Target class \"${target}\" passed in to the \"DefinitionsFactory#createForClass()\" method is \"undefined\".`);\n    }\n    let schemaDefinition = {};\n    let parent = target;\n    while (!(0, shared_utils_1.isUndefined)(parent.prototype)) {\n      if (parent === Function.prototype) {\n        break;\n      }\n      const schemaMetadata = type_metadata_storage_1.TypeMetadataStorage.getSchemaMetadataByTarget(parent);\n      if (!schemaMetadata) {\n        parent = Object.getPrototypeOf(parent);\n        continue;\n      }\n      schemaMetadata.properties?.forEach(item => {\n        const options = this.inspectTypeDefinition(item.options);\n        this.inspectRef(item.options);\n        schemaDefinition = {\n          [item.propertyKey]: options,\n          ...schemaDefinition\n        };\n      });\n      parent = Object.getPrototypeOf(parent);\n    }\n    return schemaDefinition;\n  }\n  static inspectTypeDefinition(optionsOrType) {\n    if (typeof optionsOrType === 'function') {\n      if (this.isPrimitive(optionsOrType)) {\n        return optionsOrType;\n      } else if (this.isMongooseSchemaType(optionsOrType)) {\n        return optionsOrType;\n      }\n      const isClass = /^class\\s/.test(Function.prototype.toString.call(optionsOrType));\n      optionsOrType = isClass ? optionsOrType : optionsOrType();\n      const schemaDefinition = this.createForClass(optionsOrType);\n      const schemaMetadata = type_metadata_storage_1.TypeMetadataStorage.getSchemaMetadataByTarget(optionsOrType);\n      if (schemaMetadata?.options) {\n        return new mongoose.Schema(schemaDefinition, schemaMetadata.options);\n      }\n      return schemaDefinition;\n    } else if (typeof optionsOrType.type === 'function' || Array.isArray(optionsOrType.type)) {\n      optionsOrType.type = this.inspectTypeDefinition(optionsOrType.type);\n      return optionsOrType;\n    } else if (Array.isArray(optionsOrType)) {\n      return optionsOrType.length > 0 ? [this.inspectTypeDefinition(optionsOrType[0])] : optionsOrType;\n    }\n    return optionsOrType;\n  }\n  static inspectRef(optionsOrType) {\n    if (!optionsOrType || typeof optionsOrType !== 'object') {\n      return;\n    }\n    if (typeof optionsOrType?.ref === 'function') {\n      try {\n        const result = optionsOrType.ref();\n        if (typeof result?.name === 'string') {\n          optionsOrType.ref = result.name;\n        }\n        optionsOrType.ref = optionsOrType.ref;\n      } catch (err) {\n        if (err instanceof TypeError) {\n          const refClassName = optionsOrType.ref?.name;\n          throw new Error(`Unsupported syntax: Class constructor \"${refClassName}\" cannot be invoked without 'new'. Make sure to wrap your class reference in an arrow function (for example, \"ref: () => ${refClassName}\").`);\n        }\n        throw err;\n      }\n    } else if (Array.isArray(optionsOrType.type)) {\n      if (optionsOrType.type.length > 0) {\n        this.inspectRef(optionsOrType.type[0]);\n      }\n    }\n  }\n  static isPrimitive(type) {\n    return BUILT_IN_TYPES.includes(type);\n  }\n  static isMongooseSchemaType(type) {\n    if (!type || !type.prototype) {\n      return false;\n    }\n    const prototype = Object.getPrototypeOf(type.prototype);\n    return prototype && prototype.constructor === mongoose.SchemaType;\n  }\n}\nexports.DefinitionsFactory = DefinitionsFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","DefinitionsFactory","shared_utils_1","require","mongoose","type_metadata_storage_1","BUILT_IN_TYPES","Boolean","Number","String","Map","Date","Buffer","BigInt","createForClass","target","Error","schemaDefinition","parent","isUndefined","prototype","Function","schemaMetadata","TypeMetadataStorage","getSchemaMetadataByTarget","getPrototypeOf","properties","forEach","item","options","inspectTypeDefinition","inspectRef","propertyKey","optionsOrType","isPrimitive","isMongooseSchemaType","isClass","test","toString","call","Schema","type","Array","isArray","length","ref","result","name","err","TypeError","refClassName","includes","constructor","SchemaType"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/mongoose/dist/factories/definitions.factory.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefinitionsFactory = void 0;\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst mongoose = require(\"mongoose\");\nconst type_metadata_storage_1 = require(\"../storages/type-metadata.storage\");\nconst BUILT_IN_TYPES = [\n    Boolean,\n    Number,\n    String,\n    Map,\n    Date,\n    Buffer,\n    BigInt,\n];\nclass DefinitionsFactory {\n    static createForClass(target) {\n        if (!target) {\n            throw new Error(`Target class \"${target}\" passed in to the \"DefinitionsFactory#createForClass()\" method is \"undefined\".`);\n        }\n        let schemaDefinition = {};\n        let parent = target;\n        while (!(0, shared_utils_1.isUndefined)(parent.prototype)) {\n            if (parent === Function.prototype) {\n                break;\n            }\n            const schemaMetadata = type_metadata_storage_1.TypeMetadataStorage.getSchemaMetadataByTarget(parent);\n            if (!schemaMetadata) {\n                parent = Object.getPrototypeOf(parent);\n                continue;\n            }\n            schemaMetadata.properties?.forEach((item) => {\n                const options = this.inspectTypeDefinition(item.options);\n                this.inspectRef(item.options);\n                schemaDefinition = {\n                    [item.propertyKey]: options,\n                    ...schemaDefinition,\n                };\n            });\n            parent = Object.getPrototypeOf(parent);\n        }\n        return schemaDefinition;\n    }\n    static inspectTypeDefinition(optionsOrType) {\n        if (typeof optionsOrType === 'function') {\n            if (this.isPrimitive(optionsOrType)) {\n                return optionsOrType;\n            }\n            else if (this.isMongooseSchemaType(optionsOrType)) {\n                return optionsOrType;\n            }\n            const isClass = /^class\\s/.test(Function.prototype.toString.call(optionsOrType));\n            optionsOrType = isClass ? optionsOrType : optionsOrType();\n            const schemaDefinition = this.createForClass(optionsOrType);\n            const schemaMetadata = type_metadata_storage_1.TypeMetadataStorage.getSchemaMetadataByTarget(optionsOrType);\n            if (schemaMetadata?.options) {\n                return new mongoose.Schema(schemaDefinition, schemaMetadata.options);\n            }\n            return schemaDefinition;\n        }\n        else if (typeof optionsOrType.type === 'function' ||\n            Array.isArray(optionsOrType.type)) {\n            optionsOrType.type = this.inspectTypeDefinition(optionsOrType.type);\n            return optionsOrType;\n        }\n        else if (Array.isArray(optionsOrType)) {\n            return optionsOrType.length > 0\n                ? [this.inspectTypeDefinition(optionsOrType[0])]\n                : optionsOrType;\n        }\n        return optionsOrType;\n    }\n    static inspectRef(optionsOrType) {\n        if (!optionsOrType || typeof optionsOrType !== 'object') {\n            return;\n        }\n        if (typeof optionsOrType?.ref === 'function') {\n            try {\n                const result = optionsOrType.ref();\n                if (typeof result?.name === 'string') {\n                    optionsOrType.ref = result.name;\n                }\n                optionsOrType.ref = optionsOrType.ref;\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    const refClassName = optionsOrType.ref?.name;\n                    throw new Error(`Unsupported syntax: Class constructor \"${refClassName}\" cannot be invoked without 'new'. Make sure to wrap your class reference in an arrow function (for example, \"ref: () => ${refClassName}\").`);\n                }\n                throw err;\n            }\n        }\n        else if (Array.isArray(optionsOrType.type)) {\n            if (optionsOrType.type.length > 0) {\n                this.inspectRef(optionsOrType.type[0]);\n            }\n        }\n    }\n    static isPrimitive(type) {\n        return BUILT_IN_TYPES.includes(type);\n    }\n    static isMongooseSchemaType(type) {\n        if (!type || !type.prototype) {\n            return false;\n        }\n        const prototype = Object.getPrototypeOf(type.prototype);\n        return prototype && prototype.constructor === mongoose.SchemaType;\n    }\n}\nexports.DefinitionsFactory = DefinitionsFactory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
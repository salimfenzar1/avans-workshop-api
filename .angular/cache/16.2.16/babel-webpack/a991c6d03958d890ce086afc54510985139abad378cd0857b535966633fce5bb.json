{"ast":null,"code":"import { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n    this.validationMetadatas = new Map();\n    this.constraintMetadatas = new Map();\n  }\n  get hasValidationMetaData() {\n    return !!this.validationMetadatas.size;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema) {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata) {\n    const existingMetadata = this.validationMetadatas.get(metadata.target);\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.validationMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata) {\n    const existingMetadata = this.constraintMetadatas.get(metadata.target);\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.constraintMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata) {\n    const grouped = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(targetConstructor, targetSchema, always, strictGroups, groups) {\n    const includeMetadataBecauseOfAlwaysOption = metadata => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n      // Use global default.\n      return always;\n    };\n    const excludeMetadataBecauseOfStrictGroupsOption = metadata => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n      return false;\n    };\n    // get directly related to a target metadatas\n    const filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];\n    const originalMetadatas = filteredForOriginalMetadatasSearch.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n      return true;\n    });\n    // get metadatas for inherited classes\n    const filteredForInheritedMetadatasSearch = [];\n    for (const [key, value] of this.validationMetadatas.entries()) {\n      if (targetConstructor.prototype instanceof key) {\n        filteredForInheritedMetadatasSearch.push(...value);\n      }\n    }\n    const inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target)) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n      return true;\n    });\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;\n      });\n    });\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target) {\n    return this.constraintMetadatas.get(target) || [];\n  }\n}\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage() {\n  const global = getGlobal();\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n  return global.classValidatorMetadataStorage;\n}","map":{"version":3,"names":["ValidationSchemaToMetadataTransformer","getGlobal","MetadataStorage","constructor","validationMetadatas","Map","constraintMetadatas","hasValidationMetaData","size","addValidationSchema","schema","transform","forEach","validationMetadata","addValidationMetadata","metadata","existingMetadata","get","target","push","set","addConstraintMetadata","groupByPropertyName","grouped","propertyName","getTargetValidationMetadatas","targetConstructor","targetSchema","always","strictGroups","groups","includeMetadataBecauseOfAlwaysOption","length","excludeMetadataBecauseOfStrictGroupsOption","filteredForOriginalMetadatasSearch","originalMetadatas","filter","find","group","indexOf","filteredForInheritedMetadatasSearch","key","value","entries","prototype","inheritedMetadatas","Function","uniqueInheritedMetadatas","inheritedMetadata","originalMetadata","type","concat","getTargetValidatorConstraints","getMetadataStorage","global","classValidatorMetadataStorage"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/class-validator/esm2015/metadata/MetadataStorage.js"],"sourcesContent":["import { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n    constructor() {\n        // -------------------------------------------------------------------------\n        // Private properties\n        // -------------------------------------------------------------------------\n        this.validationMetadatas = new Map();\n        this.constraintMetadatas = new Map();\n    }\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.size;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata) {\n        const existingMetadata = this.validationMetadatas.get(metadata.target);\n        if (existingMetadata) {\n            existingMetadata.push(metadata);\n        }\n        else {\n            this.validationMetadatas.set(metadata.target, [metadata]);\n        }\n    }\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata) {\n        const existingMetadata = this.constraintMetadatas.get(metadata.target);\n        if (existingMetadata) {\n            existingMetadata.push(metadata);\n        }\n        else {\n            this.constraintMetadatas.set(metadata.target, [metadata]);\n        }\n    }\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata) {\n        const grouped = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor, targetSchema, always, strictGroups, groups) {\n        const includeMetadataBecauseOfAlwaysOption = (metadata) => {\n            // `metadata.always` overrides global default.\n            if (typeof metadata.always !== 'undefined')\n                return metadata.always;\n            // `metadata.groups` overrides global default.\n            if (metadata.groups && metadata.groups.length)\n                return false;\n            // Use global default.\n            return always;\n        };\n        const excludeMetadataBecauseOfStrictGroupsOption = (metadata) => {\n            if (strictGroups) {\n                // Validation is not using groups.\n                if (!groups || !groups.length) {\n                    // `metadata.groups` has at least one group.\n                    if (metadata.groups && metadata.groups.length)\n                        return true;\n                }\n            }\n            return false;\n        };\n        // get directly related to a target metadatas\n        const filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];\n        const originalMetadatas = filteredForOriginalMetadatasSearch.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (includeMetadataBecauseOfAlwaysOption(metadata))\n                return true;\n            if (excludeMetadataBecauseOfStrictGroupsOption(metadata))\n                return false;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n            return true;\n        });\n        // get metadatas for inherited classes\n        const filteredForInheritedMetadatasSearch = [];\n        for (const [key, value] of this.validationMetadatas.entries()) {\n            if (targetConstructor.prototype instanceof key) {\n                filteredForInheritedMetadatasSearch.push(...value);\n            }\n        }\n        const inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(metadata => {\n            // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === 'string')\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n                return false;\n            if (includeMetadataBecauseOfAlwaysOption(metadata))\n                return true;\n            if (excludeMetadataBecauseOfStrictGroupsOption(metadata))\n                return false;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n            return true;\n        });\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return (originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                    originalMetadata.type === inheritedMetadata.type);\n            });\n        });\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target) {\n        return this.constraintMetadatas.get(target) || [];\n    }\n}\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage() {\n    const global = getGlobal();\n    if (!global.classValidatorMetadataStorage) {\n        global.classValidatorMetadataStorage = new MetadataStorage();\n    }\n    return global.classValidatorMetadataStorage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
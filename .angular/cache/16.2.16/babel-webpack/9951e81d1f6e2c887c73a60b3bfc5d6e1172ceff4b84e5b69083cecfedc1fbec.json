{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContextIdFactory = void 0;\nexports.createContextId = createContextId;\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst request_constants_1 = require(\"../router/request/request-constants\");\nfunction createContextId() {\n  /**\n   * We are generating random identifier to track asynchronous\n   * execution context. An identifier does not have to be neither unique\n   * nor unpredictable because WeakMap uses objects as keys (reference comparison).\n   * Thus, even though identifier number might be equal, WeakMap would properly\n   * associate asynchronous context with its internal map values using object reference.\n   * Object is automatically removed once request has been processed (closure).\n   */\n  return {\n    id: Math.random()\n  };\n}\nclass ContextIdFactory {\n  /**\n   * Generates a context identifier based on the request object.\n   */\n  static create() {\n    return createContextId();\n  }\n  /**\n   * Generates a random identifier to track asynchronous execution context.\n   * @param request request object\n   */\n  static getByRequest(request, propsToInspect = ['raw']) {\n    if (!request) {\n      return ContextIdFactory.create();\n    }\n    if (request[request_constants_1.REQUEST_CONTEXT_ID]) {\n      return request[request_constants_1.REQUEST_CONTEXT_ID];\n    }\n    for (const key of propsToInspect) {\n      if (request[key]?.[request_constants_1.REQUEST_CONTEXT_ID]) {\n        return request[key][request_constants_1.REQUEST_CONTEXT_ID];\n      }\n    }\n    if (!this.strategy) {\n      return ContextIdFactory.create();\n    }\n    const contextId = createContextId();\n    const resolverObjectOrFunction = this.strategy.attach(contextId, request);\n    if (this.isContextIdResolverWithPayload(resolverObjectOrFunction)) {\n      contextId.getParent = resolverObjectOrFunction.resolve;\n      contextId.payload = resolverObjectOrFunction.payload;\n    } else {\n      contextId.getParent = resolverObjectOrFunction;\n    }\n    return contextId;\n  }\n  /**\n   * Registers a custom context id strategy that lets you attach\n   * a parent context id to the existing context id object.\n   * @param strategy strategy instance\n   */\n  static apply(strategy) {\n    this.strategy = strategy;\n  }\n  static isContextIdResolverWithPayload(resolverOrResolverFn) {\n    return (0, shared_utils_1.isObject)(resolverOrResolverFn);\n  }\n}\nexports.ContextIdFactory = ContextIdFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","ContextIdFactory","createContextId","shared_utils_1","require","request_constants_1","id","Math","random","create","getByRequest","request","propsToInspect","REQUEST_CONTEXT_ID","key","strategy","contextId","resolverObjectOrFunction","attach","isContextIdResolverWithPayload","getParent","resolve","payload","apply","resolverOrResolverFn","isObject"],"sources":["C:/Users/salim/Dev/avans-nx-workshop-2024/avans-nx-workshop/node_modules/@nestjs/core/helpers/context-id-factory.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextIdFactory = void 0;\nexports.createContextId = createContextId;\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\nconst request_constants_1 = require(\"../router/request/request-constants\");\nfunction createContextId() {\n    /**\n     * We are generating random identifier to track asynchronous\n     * execution context. An identifier does not have to be neither unique\n     * nor unpredictable because WeakMap uses objects as keys (reference comparison).\n     * Thus, even though identifier number might be equal, WeakMap would properly\n     * associate asynchronous context with its internal map values using object reference.\n     * Object is automatically removed once request has been processed (closure).\n     */\n    return { id: Math.random() };\n}\nclass ContextIdFactory {\n    /**\n     * Generates a context identifier based on the request object.\n     */\n    static create() {\n        return createContextId();\n    }\n    /**\n     * Generates a random identifier to track asynchronous execution context.\n     * @param request request object\n     */\n    static getByRequest(request, propsToInspect = ['raw']) {\n        if (!request) {\n            return ContextIdFactory.create();\n        }\n        if (request[request_constants_1.REQUEST_CONTEXT_ID]) {\n            return request[request_constants_1.REQUEST_CONTEXT_ID];\n        }\n        for (const key of propsToInspect) {\n            if (request[key]?.[request_constants_1.REQUEST_CONTEXT_ID]) {\n                return request[key][request_constants_1.REQUEST_CONTEXT_ID];\n            }\n        }\n        if (!this.strategy) {\n            return ContextIdFactory.create();\n        }\n        const contextId = createContextId();\n        const resolverObjectOrFunction = this.strategy.attach(contextId, request);\n        if (this.isContextIdResolverWithPayload(resolverObjectOrFunction)) {\n            contextId.getParent = resolverObjectOrFunction.resolve;\n            contextId.payload = resolverObjectOrFunction.payload;\n        }\n        else {\n            contextId.getParent = resolverObjectOrFunction;\n        }\n        return contextId;\n    }\n    /**\n     * Registers a custom context id strategy that lets you attach\n     * a parent context id to the existing context id object.\n     * @param strategy strategy instance\n     */\n    static apply(strategy) {\n        this.strategy = strategy;\n    }\n    static isContextIdResolverWithPayload(resolverOrResolverFn) {\n        return (0, shared_utils_1.isObject)(resolverOrResolverFn);\n    }\n}\nexports.ContextIdFactory = ContextIdFactory;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,gBAAgB,GAAG,KAAK,CAAC;AACjCF,OAAO,CAACG,eAAe,GAAGA,eAAe;AACzC,MAAMC,cAAc,GAAGC,OAAO,CAAC,mCAAmC,CAAC;AACnE,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,qCAAqC,CAAC;AAC1E,SAASF,eAAeA,CAAA,EAAG;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAO;IAAEI,EAAE,EAAEC,IAAI,CAACC,MAAM,CAAC;EAAE,CAAC;AAChC;AACA,MAAMP,gBAAgB,CAAC;EACnB;AACJ;AACA;EACI,OAAOQ,MAAMA,CAAA,EAAG;IACZ,OAAOP,eAAe,CAAC,CAAC;EAC5B;EACA;AACJ;AACA;AACA;EACI,OAAOQ,YAAYA,CAACC,OAAO,EAAEC,cAAc,GAAG,CAAC,KAAK,CAAC,EAAE;IACnD,IAAI,CAACD,OAAO,EAAE;MACV,OAAOV,gBAAgB,CAACQ,MAAM,CAAC,CAAC;IACpC;IACA,IAAIE,OAAO,CAACN,mBAAmB,CAACQ,kBAAkB,CAAC,EAAE;MACjD,OAAOF,OAAO,CAACN,mBAAmB,CAACQ,kBAAkB,CAAC;IAC1D;IACA,KAAK,MAAMC,GAAG,IAAIF,cAAc,EAAE;MAC9B,IAAID,OAAO,CAACG,GAAG,CAAC,GAAGT,mBAAmB,CAACQ,kBAAkB,CAAC,EAAE;QACxD,OAAOF,OAAO,CAACG,GAAG,CAAC,CAACT,mBAAmB,CAACQ,kBAAkB,CAAC;MAC/D;IACJ;IACA,IAAI,CAAC,IAAI,CAACE,QAAQ,EAAE;MAChB,OAAOd,gBAAgB,CAACQ,MAAM,CAAC,CAAC;IACpC;IACA,MAAMO,SAAS,GAAGd,eAAe,CAAC,CAAC;IACnC,MAAMe,wBAAwB,GAAG,IAAI,CAACF,QAAQ,CAACG,MAAM,CAACF,SAAS,EAAEL,OAAO,CAAC;IACzE,IAAI,IAAI,CAACQ,8BAA8B,CAACF,wBAAwB,CAAC,EAAE;MAC/DD,SAAS,CAACI,SAAS,GAAGH,wBAAwB,CAACI,OAAO;MACtDL,SAAS,CAACM,OAAO,GAAGL,wBAAwB,CAACK,OAAO;IACxD,CAAC,MACI;MACDN,SAAS,CAACI,SAAS,GAAGH,wBAAwB;IAClD;IACA,OAAOD,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOO,KAAKA,CAACR,QAAQ,EAAE;IACnB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC5B;EACA,OAAOI,8BAA8BA,CAACK,oBAAoB,EAAE;IACxD,OAAO,CAAC,CAAC,EAAErB,cAAc,CAACsB,QAAQ,EAAED,oBAAoB,CAAC;EAC7D;AACJ;AACAzB,OAAO,CAACE,gBAAgB,GAAGA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}